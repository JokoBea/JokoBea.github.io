<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> | Hurn's Blog</title><meta name="description" content=" - Hurn"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hurn's Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Hurn's Blog"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/Dreyer" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">(untitled)</h1><div class="post-info"><a></a>2023-07-12</div><div class="post-content"><h1 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h1><p>假设一个Java反序列化漏洞可利用的点，这个路径(C:\Users\Administrator\Desktop\2.bin)可控，大多数情况是这样 readObject函数的输入可控，这样就可以构造一个恶意类进一步执行恶意代码了。</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712104504093.png" alt="image-20230712104504093"></p>
<p>举个例子看看效果，使用<code>YSOSerial</code>生成DNSLOG Payload测试</p>
<pre><code class="shell">C:\Users\Administrator\Desktop&gt;&quot;C:\Program Files\Java\jdk1.7.0_80\bin\java&quot; -jar ysoserial-main-923a2bda4e-1.jar URLDNS &quot;https://hqbp28fmc8xxu9169u1vkmifv61zpqdf.oastify.com&quot; &gt;2.bin
</code></pre>
<p>运行之后可以看到触发了DNS</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712110311203.png" alt="image-20230712110311203"></p>
<p>分析原因，跟进<code>ois.readObject</code> </p>
<p>可以看到readObject实际调用的<code>readObject0</code></p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712110526893.png" alt="image-20230712110526893"></p>
<p>在<code>readObject0</code>中，读取整个流文件，如果读取到<code>0x73</code>则说明这是个普通类文件，进一步调用<code>readOrdinaryObject</code></p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712110934000.png" alt="image-20230712110934000"></p>
<p>在<code>readOrdinaryObject</code>中主要是对类进行检查，是否为<code>0x73</code>，String、Class、ObjectStreamClass类不可序列化，是否继承了Serialable接口</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712111353204.png" alt="image-20230712111353204"></p>
<p>如果不是继承Externalizable接口，则会调用readSerialData</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712111847148.png" alt="image-20230712111847148"></p>
<p>其中会获取类结构，执行该类的readObject方法，这就是反序列化梦开始的地方，<strong>会执行输入数据类的readObject方法</strong>，</p>
<p>总结，我们要利用反序列化漏洞，就需要两个前提条件：</p>
<ul>
<li><p>readObject的输入数据可控</p>
</li>
<li><p>需要一个类，这个类也叫gadge，其中的readObect方法可以构造恶意代码，类似于下面这种，但没有这么简单，需要构造一个链</p>
<pre><code>public class Test implements Serializable &#123;

    private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException &#123;
        Runtime.getRuntime().exec(&quot;calc.exe&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>需要对方环境的依赖中有这个gadget类</p>
</li>
</ul>
<h1 id="0x1-Gadget"><a href="#0x1-Gadget" class="headerlink" title="0x1 Gadget"></a>0x1 Gadget</h1><p>Gadget（<code>a small device or machine with a particular purpose</code>），其实就可以理解为payload，这个pyaload一般由三部分组成，”kick-off” =&gt; “入口点（重写了 readObject 的类)”、”sink” =&gt; “最终执行恶意动作的点：RCE等”、”chain =&gt;中间的调用链 “。</p>
<h1 id="0x2-URLDNS"><a href="#0x2-URLDNS" class="headerlink" title="0x2 URLDNS"></a>0x2 URLDNS</h1><p><strong>ysoserial的payload：</strong> 使用HashMap作为入口点，将URL类作为键，当HashMap序列化时会对键进行hashCode计算，触发URL.hashCode进行DNS请求</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712122119504.png" alt="image-20230712122119504"></p>
<p><strong>调用链：</strong></p>
<pre><code>HashMap.readObject()
    *HashMap.put()
        HashMap.putVal()
            HashMap.hash()
                URL.hashCode()
                    URLStreamHandler.hashCode()
                        URLStreamHandler.getHostAddress()
</code></pre>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712121653379.png" alt="image-20230712121653379"></p>
<p>可以看到kick-off 入口点是HashMap，在HashMap的readObject中会对key进行hash计算</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712122638425.png" alt="image-20230712122638425"></p>
<p>这个Key为java.net.URL类</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712122703582.png" alt="image-20230712122703582"></p>
<p>调用URL类的hashCode函数</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712122855610.png" alt="image-20230712122855610"></p>
<p>触发DNS请求</p>
<p><img src="/2023/07/12/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/CpZO/blog/source/_posts/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.assets/image-20230712123141202.png" alt="image-20230712123141202"></p>
<h1 id="0x4-总结"><a href="#0x4-总结" class="headerlink" title="0x4 总结"></a>0x4 总结</h1><p>URLDNS这个Gadget 的 Sink为 java.net.URL， Source为HashMap，通过HashCode方法触发。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2023/07/13/Java/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%963/">prev</a><a class="next" href="/2022/08/21/CryptoPP/">next</a></div><div class="copyright"><p>&copy; 2023 <a href="http://example.com">Hurn</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>