<!DOCTYPE html><html lang="zh"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=0.5"><link rel="stylesheet" href="/css/post.css"><link rel="icon" href="/img/favicon.png"><title>Windows认证及协议</title><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body>　　<div class="inner"><h2>Windows认证及协议</h2><h1 id="Windows认证及协议"><a href="#Windows认证及协议" class="headerlink" title="Windows认证及协议"></a>Windows认证及协议</h1><p>Windows的认证包括三个部分，用户直接操作计算机登陆账户（本地认证），远程连接到工作组中的某个设备（网络认证），登陆到域环境中的某个设备（域认证）</p>
<h1 id="一、本地认证"><a href="#一、本地认证" class="headerlink" title="一、本地认证"></a>一、本地认证</h1><p>用户输入密码，系统收到密码后将用户输入的密码计算成NTLM Hash，然后与sam数据库（%SystemRoot%\system32\config\sam）中该用户的哈希比对，匹配则登陆成功，不匹配则登陆失败。 </p>
<p>本地认证中用来处理用户输入密码的进程即lsass.exe,密码会在这个进程中明文保存，供该进程将密码计算成NTLM Hash与sam进行比对。</p>
<p>NTML 运算流程：</p>
<p><code>用户密码-&gt;HEX编码-&gt;Unicode编码-&gt;MD4</code></p>
<p><img src="/2022/05/01/Windows%E8%AE%A4%E8%AF%81%203157107054db4a068847bd6a2a372bb9/Untitled.png" alt="Untitled"></p>
<h1 id="二、网络认证-NTML"><a href="#二、网络认证-NTML" class="headerlink" title="二、网络认证 (NTML)"></a>二、网络认证 (NTML)</h1><p>网络认证即在工作组环境下远程登陆另一台电脑所采用的认证机制</p>
<p>NTLM协议的认证过程分为三步，也叫挑战相应机制：</p>
<ul>
<li>协商 ，确定双方使用的协议版本， NTLM V1 或者 NTML V2 ，加密不同<ol>
<li>客户端向服务端发送用户信息（用户名）请求</li>
</ol>
</li>
<li>质询，挑战（Challenge） 和 响应（ Response）认证机制的核心<ol>
<li>服务端接受客户端请求之后先判断用户名是否在本地存在，如果不存在则认证失败。</li>
<li>服务端生成一个Challenge（16位的随机字符串），使用该用户的NTML Hash加密Challenge，生成Challenge1，并且将Challenge发送给客户端</li>
<li>客户端收到Challenge之后，用自己的NTML Hash加密该Challenge，发送给服务端</li>
</ol>
</li>
<li>验证，在质询完成后，验证结果<ol>
<li>服务端收到后与自己内存中的Chanllege1对比，正确则认证成功</li>
</ol>
</li>
</ul>
<blockquote>
<p>简单的来说：客户端向服务器请求使用某个用户进行验证，服务端判断该用户是否存在，存在的话使用这个用户密码的哈希值来加密一个随机字符串，并且将这个随机字符串返回给客户端，客户端再把自己提供的密码进行哈希处理后也来加密这串随机字符串，然后再把结果发送给服务器，服务器把从客户端发送的加密结果与自己本地的加密结果进行比较，相同的话便通过认证</p>
</blockquote>
<p><code>其中的关键点在于：第二步中客户端发送的是NTLM哈希值与随机字符串加密的结果，而这个NTLM哈希是由用户输入的密码本地计算得出的，所以在这个步骤中，只要能提供正确的NTLM哈希即使不知道正确的密码也可通过认证，这也是能进行PTH攻击的原因。</code></p>
<p>批量安装的机器可能账户密码信息都是一样的，所以可以用Hash去传递登陆。</p>
<h1 id="三、域认证（Kerberos"><a href="#三、域认证（Kerberos" class="headerlink" title="三、域认证（Kerberos)"></a>三、域认证（Kerberos)</h1><p>简单概述：</p>
<p><img src="/2022/05/01/Windows%E8%AE%A4%E8%AF%81%203157107054db4a068847bd6a2a372bb9/Untitled%201.png" alt="Untitled"></p>
<ol>
<li>客户端使用发起认证用户的Hash加密时间戳给KDC进行身份证明</li>
<li>KDC使用该用户的Hash进行解密该时间戳，若正确则返回由krbtgt hash加密的TGT，表示该客户端身份正确可以进行票据申请</li>
<li>客户端使用TGT去请求特定服务的TGS，用来访问该服务</li>
<li>KDC使用krbtgt hash进行解密，正确则返回票据（未进行访问服务的权限判断）</li>
<li>客户端拿着由KDC授权的TGS去访问资源服务</li>
<li>资源服务用自己的hash能解密则说明认证成功，接着进行PAC权限认证。</li>
</ol>
<h1 id="四、域管理（LDAP）"><a href="#四、域管理（LDAP）" class="headerlink" title="四、域管理（LDAP）"></a>四、域管理（LDAP）</h1><p>域中最核心的就是活动目录（Active Directory），相当于域里面所有资源的目录，域中的资源如何搜索和进行访问控制呢，这就需要 LDAP（Lightweight Directory Access Protocol）轻量目录访问协议。</p>
<p>活动目录中，为了分布存储、隔离数据和搜索，划分三个命名空间（Naming Context，缩写为NC）</p>
<img src="/2022/05/01/Windows%E8%AE%A4%E8%AF%81%203157107054db4a068847bd6a2a372bb9/image-20220814090409739.png" alt="image-20220814090409739" style="zoom:30%;">

<ul>
<li>Domain NC，包含特定域的数据，例如用户、计算机等。</li>
<li>Configuration NC，林配置信息的主要存储库，包括有关站点、服务、分区、权限控制和Active Directory Schema的信息。</li>
<li>Schema NC，定义ActiveDirectory中使用的类，对象和属性，属于Configuration NC。</li>
</ul>
<p>域内安全组（用户的权限范围）划分：</p>
<ul>
<li>域本地组（Domain Local group），可以将任何域中的用户账户、通用组和全局组添加到域本地组。域本地组不能嵌套于其他组中，<strong>它主要是用于授予位于本域资源的访问权限</strong>。</li>
<li>通用组（Universal group），可以从任何域中添加用户和组，可以嵌套于其他域组中。例如”Enterprise Admins”，<strong>作用于全林</strong>，可访问或者管理全林的资源。</li>
<li>全局组（Global group），<strong>只能在创建该全局组的域上进行添加用户账户和全局组</strong>，但全局组可以嵌套在其他组中。如果其他域想访问本域的资源可以加入到本域的全局组，而全局组嵌套给域本地组。例如Domain Admin，只能管理本域的资源，不能控制其他域。</li>
</ul>
<blockquote>
<p>全局组引用一个例子：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bytxl/article/details/7690597">https://blog.csdn.net/bytxl/article/details/7690597</a></p>
<p><strong>比如：</strong> 有两个域，A和B，A中的5个财务人员和B中的3个财务人员都需要访问B中的“FINA”文件夹。这时，可以在B中建一个DL，因为DL的成员可以来自所有的域，然后把这8个人都加入这个DL，并把FINA的访问权赋给DL。这样做的坏处是什么呢？因为DL是在B域中，所以管理权也在B域，如果A域中的5个人变成6个人，那只能A域管理员通知B域管理员，将DL的成员做一下修改，B域的管理员太累了。</p>
<p>这时候，我们改变一下，在A和B域中都各建立一个全局组（G），然后在B域中建立一个DL，把这两个G都加入B域中的DL中，然后把FINA的访问权赋给DL。哈哈，这下两个G组都有权访问FINA文件夹了    ，是吗？组嵌套造成权限继承嘛！这时候，两个G分布在A和B域中，也就是A和B的管理员都可以自己管理自己的G啦，只要把那5个人和3个人加入G中，就可以了！以后有任何修改，都可以自己做了，不用麻烦B域的管理员！这就是A-G-DL-P。</p>
</blockquote>
<h1 id="五、相关攻击面总结"><a href="#五、相关攻击面总结" class="headerlink" title="五、相关攻击面总结"></a>五、相关攻击面总结</h1><ol>
<li>在NTML协议中，服务端的验证方式为hash + chanllenge，所以拥有用户的hash之后即可进行PTH攻击。</li>
<li>在NTML协议中，可以进行中间人攻击，也就是NTML Relay，这种Relay即可以攻击别人也能攻击自己（权限提升，一堆土豆）。</li>
<li>在Kerberose协议中，AS-REQ阶段，可以进行用户名枚举、密码碰洒、AS-REPRoasting，如果拿到hash，还可以进行PTH/PTK，甚至制作黄金票据。</li>
<li>在Kerberose协议中，TGS-REQ/TGS-REP阶段，服务配置不当，可以进行服务委派攻击，有服务hash则可以制作白银票据。</li>
</ol>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://daiker.gitbook.io/windows-protocol/">https://daiker.gitbook.io/windows-protocol/</a></p>
<p><a target="_blank" rel="noopener" href="https://ares-x.com/2020/03/17/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Kerberos%E5%8D%8F%E8%AE%AE/">https://ares-x.com/2020/03/17/域渗透学习（二）Kerberos协议/</a></p>
</div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script></body></html>