<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Go并发 | Hurn's Blog</title><meta name="description" content="Go并发 - Hurn"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hurn's Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Hurn's Blog"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/Dreyer" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Go并发</h1><div class="post-info"><a></a>2022-07-03</div><div class="post-content"><blockquote>
<p>学习、记录几种基础并发模式</p>
</blockquote>
<p>Golang中最显眼的标签之一就是高并发，在Go里面使用<code>go</code>关键字轻松实现Gorutine并发，那么在并发中如何控制资源、交换数据呢，下面记录几种基础的并发模式</p>
<h1 id="0x1-锁"><a href="#0x1-锁" class="headerlink" title="0x1. 锁"></a>0x1. 锁</h1><p>通过锁来控制资源</p>
<ul>
<li>互斥锁</li>
</ul>
<pre><code class="go">func main() &#123;
    var mu sync.Mutex

    mu.Lock()
    go func()&#123;
        fmt.Println(&quot;你好, 世界&quot;)
        mu.Unlock()
    &#125;()

    mu.Lock()
&#125;
</code></pre>
<p>当第二次加锁时会因为锁已经被占用（不是递归锁）而阻塞，<code>main</code>函数的阻塞状态驱动后台线程继续向前执行。当后台线程执行到<code>mu.Unlock()</code>时解锁，此时打印工作已经完成了，解锁会导致<code>main</code>函数中的第二个<code>mu.Lock()</code>阻塞状态取消，此时后台线程和主线程再没有其它的同步事件参考，它们退出的事件将是并发的：在<code>main</code>函数退出导致程序退出时，后台线程可能已经退出了，也可能没有退出。虽然无法确定两个线程退出的时间，但是打印工作是可以正确完成的。</p>
<ul>
<li>信道</li>
</ul>
<pre><code class="go">func main() &#123;
    done := make(chan int, 1) // 带缓存的管道

    go func()&#123;
        fmt.Println(&quot;你好, 世界&quot;)
        // 发送信号
        done &lt;- 1
    &#125;()
        // 未收到信号会一直阻塞
    &lt;-done
&#125;
</code></pre>
<ul>
<li>sync.WaitGroup</li>
</ul>
<pre><code class="go">func main() &#123;
    var wg sync.WaitGroup

    // 开N个后台打印线程
    for i := 0; i &lt; 10; i++ &#123;
        wg.Add(1)

        go func() &#123;
            fmt.Println(&quot;你好, 世界&quot;)
            wg.Done()
        &#125;()
    &#125;

    // 等待N个后台线程完成
    wg.Wait()
&#125;
</code></pre>
<h1 id="0x2-生产者消费者模型"><a href="#0x2-生产者消费者模型" class="headerlink" title="0x2. 生产者消费者模型"></a>0x2. 生产者消费者模型</h1><pre><code class="go">// 生产者: 生成 factor 整数倍的序列
func Producer(factor int, out chan&lt;- int) &#123;
    for i := 0; ; i++ &#123;
        out &lt;- i*factor
    &#125;
&#125;

// 消费者
func Consumer(in &lt;-chan int) &#123;
    for v := range in &#123;
        fmt.Println(v)
    &#125;
&#125;
func main() &#123;
    ch := make(chan int, 64) // 成果队列

    go Producer(3, ch) // 生成 3 的倍数的序列
    go Producer(5, ch) // 生成 5 的倍数的序列
    go Consumer(ch)    // 消费 生成的队列

    // 运行一定时间后退出
    time.Sleep(5 * time.Second)
&#125;
</code></pre>
<h1 id="0x3-发布-订阅模型"><a href="#0x3-发布-订阅模型" class="headerlink" title="0x3. 发布/订阅模型"></a>0x3. 发布/订阅模型</h1><pre><code class="go">package test

import (
    &quot;sync&quot;
    &quot;time&quot;
)

type (
  // 订阅者
    subscriber chan interface&#123;&#125;
  // 话题
    topicFunc  func(v interface&#123;&#125;) bool
)

type Publisher struct &#123;
    m           sync.RWMutex
    buffer      int
    timeout     time.Duration
    subscribers map[subscriber]topicFunc
&#125;

func NewPublisher(publishTimeout time.Duration, buffer int) *Publisher &#123;
    return &amp;Publisher&#123;
        buffer:      buffer,
        timeout:     publishTimeout,
        subscribers: make(map[subscriber]topicFunc),
    &#125;
&#125;

// 订阅所有类
func (p *Publisher) Subscribe() chan interface&#123;&#125; &#123;
    return p.SubscribeTopic(nil)
&#125;

// 添加订阅，加入map
func (p *Publisher) SubscribeTopic(topic topicFunc) chan interface&#123;&#125; &#123;
    ch := make(chan interface&#123;&#125;, p.buffer)
    p.m.Lock()
    p.subscribers[ch] = topic
    p.m.Unlock()
    return ch
&#125;

// 退出订阅，删除map选项
func (p *Publisher) Evict(sub chan interface&#123;&#125;) &#123;
    p.m.Lock()
    defer p.m.Unlock()
    delete(p.subscribers, sub)
    close(sub)
&#125;

// 遍历所有订阅并通知
func (p *Publisher) Publish(v interface&#123;&#125;) &#123;
    p.m.RLock()
    defer p.m.RUnlock()

    var wg sync.WaitGroup
    for sub, topic := range p.subscribers &#123;
        wg.Add(1)
        go p.sendTopic(sub, topic, v, &amp;wg)
    &#125;
    wg.Wait()
&#125;

// 关闭
func (p *Publisher) Close() &#123;
    p.m.Lock()
    defer p.m.Unlock()

    for sub := range p.subscribers &#123;
        delete(p.subscribers, sub)
        close(sub)
    &#125;
&#125;
// 通知订阅
func (p *Publisher) sendTopic(sub subscriber, topic topicFunc, v interface&#123;&#125;, wg *sync.WaitGroup) &#123;
    defer wg.Done()
    if topic != nil &amp;&amp; !topic(v) &#123;
        return
    &#125;

    select &#123;
    case sub &lt;- v:
    case &lt;-time.After(p.timeout):
    &#125;
&#125;
</code></pre>
<p>测试：</p>
<pre><code class="go">package test

import (
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;testing&quot;
    &quot;time&quot;
)

func TestPubSub(t *testing.T) &#123;
    p := NewPublisher(100*time.Millisecond, 10)
    defer p.Close()

    all := p.Subscribe()
    golang := p.SubscribeTopic(func(v interface&#123;&#125;) bool &#123;
        if s, ok := v.(string); ok &#123;
            return strings.Contains(s, &quot;golang&quot;)
        &#125;
        return false
    &#125;)

    p.Publish(&quot;Hello world!&quot;)
    p.Publish(&quot;Hello golang&quot;)

    go func() &#123;
        for msg := range all &#123;
            fmt.Println(&quot;all: &quot;, msg)
        &#125;
    &#125;()

    go func() &#123;
        for msg := range golang &#123;
            fmt.Println(&quot;golang:&quot;, msg)
        &#125;
    &#125;()
    time.Sleep(3 * time.Second)
&#125;
</code></pre>
<h1 id="0x4-抢占模型"><a href="#0x4-抢占模型" class="headerlink" title="0x4. 抢占模型"></a>0x4. 抢占模型</h1><p>看谁快就用谁</p>
<pre><code class="go">func TestG(t *testing.T) &#123;
    ch := make(chan string, 32)
    go func() &#123;
        ch &lt;- &quot;search by bing&quot;
    &#125;()

    go func() &#123;
        ch &lt;- &quot;search by baidu&quot;
    &#125;()

    go func() &#123;
        ch &lt;- &quot;search by google&quot;
    &#125;()

    fmt.Println(&lt;-ch)
&#125;
</code></pre>
<h1 id="0x5-并发控制"><a href="#0x5-并发控制" class="headerlink" title="0x5. 并发控制"></a>0x5. 并发控制</h1><ul>
<li>限制速率</li>
</ul>
<p>通过信道缓存控制速率：</p>
<pre><code class="go">var limit = make(chan int, 3)

func main() &#123;
    for _, w := range work &#123;
        go func() &#123;
            limit &lt;- 1
            w()
            &lt;-limit
        &#125;()
    &#125;
    select&#123;&#125;
&#125;
</code></pre>
<p>通过信号量控制：</p>
<pre><code class="go">type PortScanner struct &#123;
    ip   string
    lock *semaphore.Weighted
&#125;

func ScanPort(ip string, port int, timeout time.Duration) &#123;
    target := fmt.Sprintf(&quot;%s:%d&quot;, ip, port)
    conn, err := net.DialTimeout(&quot;tcp&quot;, target, timeout)

    if err != nil &#123;
        if strings.Contains(err.Error(), &quot;too many open files&quot;) &#123;
            fmt.Println(err.Error())
            time.Sleep(timeout)
            ScanPort(ip, port, timeout)
        &#125; else &#123;
            //fmt.Println(port, &quot;closed&quot;)
        &#125;
        return
    &#125;

    conn.Close()
    fmt.Println(port, &quot;open&quot;)
&#125;

func (ps *PortScanner) Start(f, l int, timeout time.Duration) &#123;
    wg := sync.WaitGroup&#123;&#125;
    defer wg.Wait()

    for port := f; port &lt;= l; port++ &#123;
        wg.Add(1)
        _ = ps.lock.Acquire(context.TODO(), 1)
        go func(port int) &#123;
            defer ps.lock.Release(1)
            defer wg.Done()
            ScanPort(ps.ip, port, timeout)
        &#125;(port)
    &#125;
&#125;

func TestPorsscan(t *testing.T) &#123;
    ps := &amp;PortScanner&#123;
        ip:   &quot;8.8.8.8&quot;,
        lock: semaphore.NewWeighted(500),
    &#125;

  ps.Start(1, 65535, 500*time.Millisecond)
&#125;
</code></pre>
<ul>
<li>安全退出</li>
</ul>
<p>通过context包，安全退出：</p>
<blockquote>
<p>Go语言中不同Goroutine之间主要依靠管道进行通信和同步。要同时处理多个管道的发送或接收操作，我们需要使用<code>select</code>关键字（这个关键字和网络编程中的<code>select</code>函数的行为类似）。当<code>select</code>有多个分支时，会随机选择一个可用的管道分支，如果没有可用的管道分支则选择<code>default</code>分支，否则会一直保存阻塞状态。</p>
</blockquote>
<pre><code class="go">func worker(ctx context.Context, wg *sync.WaitGroup) error &#123;
    defer wg.Done()

    for &#123;
        select &#123;
        default:
            fmt.Println(&quot;hello&quot;)
        // 等待关闭信号
        case &lt;-ctx.Done():
            return ctx.Err()
        &#125;
    &#125;
&#125;

func main() &#123;
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)

    var wg sync.WaitGroup
    for i := 0; i &lt; 10; i++ &#123;
        wg.Add(1)
        go worker(ctx, &amp;wg)
    &#125;

    time.Sleep(time.Second)
    // 发送关闭信号
    cancel()

    wg.Wait()
&#125;
</code></pre>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2022/07/05/Java/Springboot%E5%88%A9%E7%94%A8/">prev</a><a class="next" href="/2022/06/20/Java/XXE/">next</a></div><div class="copyright"><p>&copy; 2023 <a href="http://example.com">Hurn</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>