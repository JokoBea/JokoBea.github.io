<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>设计模式 | Hurn's Blog</title><meta name="description" content="设计模式 - Hurn"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hurn's Blog"><meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="wrap"><header><h1 class="branding"><a href="/" title="Hurn's Blog"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/Dreyer" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">设计模式</h1><div class="post-info"><a></a>2022-01-09</div><div class="post-content"><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><ul>
<li>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，<code>所有依赖的对象都得到通知并自动更新</code>。</li>
<li>将功能分割后，不用再维护各组件间的统一性，使用此模式动态更新。</li>
<li>适用于一个对象改变后需要通知其他对象的场景。</li>
<li>案例，模仿热水器的工作</li>
</ul>
<pre><code class="python">from abc import abstractmethod, ABCMeta


# 监听模式 ，热水器是被监听 ， 热水模式为监听 ,温度为监听属性

class WaterHeater:
    def __init__(self):
        self.__observers = []
        self.__temperature = 0
        print(&quot;【初始化】热水器开始工作啦~~~&quot;)

    def set_temperature(self, t):
        if 0 &lt; t &lt;= 200:
            print(&quot;【设置温度】将温度设置为：&quot;, t)
            self.__temperature = t
            self.update()

    def get_temperature(self):
        return self.__temperature

    def add_observers(self, observer):
        self.__observers.append(observer)

    def update(self):
        if len(self.__observers) &gt; 0:
            for o in self.__observers:
                # 把自己传递过去
                o.update(self)


class Observer(metaclass=ABCMeta):
    @abstractmethod
    def update(self, waterHeater):
        pass


class WashingMode(Observer):
    def update(self, waterHeater):
        if waterHeater.get_temperature() &gt; 70:
            print(&quot;【洗澡模式】 开始洗白白~ &quot;)


class DrinkingMode(Observer):
    def update(self, waterHeater):
        if waterHeater.get_temperature() &gt;= 100:
            print(&quot;【饮用模式】 水可以喝了~ &quot;)


class PlayingMode(Observer):
    def update(self, waterHeater):
        if 30 &lt; waterHeater.get_temperature() &lt; 50:
            print(&quot;【快乐模式】 尽情嗨皮吧~ &quot;)


if __name__ == &#39;__main__&#39;:
    myWaterHeater = WaterHeater()
    myWaterHeater.add_observers(WashingMode())
    myWaterHeater.add_observers(DrinkingMode())
    myWaterHeater.add_observers(PlayingMode())

    myWaterHeater.set_temperature(10)
    myWaterHeater.set_temperature(40)
    myWaterHeater.set_temperature(70)
    myWaterHeater.set_temperature(90)
    myWaterHeater.set_temperature(110)

# output
【初始化】热水器开始工作啦~~~
【设置温度】将温度设置为： 10
【设置温度】将温度设置为： 40
【快乐模式】 尽情嗨皮吧~ 
【设置温度】将温度设置为： 70
【设置温度】将温度设置为： 90
【洗澡模式】 开始洗白白~ 
【设置温度】将温度设置为： 110
【洗澡模式】 开始洗白白~ 
【饮用模式】 水可以喝了~ 
</code></pre>
<ul>
<li>主要代码  ，设置被监听的属性，如果改变则更新同步到所有的监听</li>
</ul>
<pre><code class="python">    def set_temperature(self, t):
        if 0 &lt; t &lt;= 200:
            print(&quot;【设置温度】将温度设置为：&quot;, t)
            self.__temperature = t
            self.update()
    
    def update(self):
        if len(self.__observers) &gt; 0:
            for o in self.__observers:
                # 把自己传递过去
                o.update(self)
</code></pre>
<ul>
<li><code>监听者模式的要点是搞清楚 谁是监听者，谁是被监听的对象， 被监听对象的属性是什么，一旦被监听者的属性发生改变则立即通知监听者（使用统一的接口update）</code></li>
<li>监听者模式的框架：</li>
</ul>
<pre><code class="python">from abc import ABCMeta, abstractmethod


class Observable:
    def __init__(self):
        self.__observers = []

    def add_observer(self, observer):
        self.__observers.append(observer)

    def remove_observer(self, observer):
        self.__observers.remove(observer)

    def notifies(self, object=0):
        for o in self.__observers:
            o.update(self, object)


class Observer(metaclass=ABCMeta):
    @abstractmethod
    def update(self, observable, object):
        pass
</code></pre>
<ul>
<li>案例，用监听者模式做异地登录检测。</li>
</ul>
<pre><code class="python"># 判断用户是否异常登录，如果正常登录则发送短信、邮件通知
# 用户为被观察者，被观察的属性为登录状态（是否异地登录），观察者（短信、邮件）
class Account(Observable):
    def __init__(self):
        super().__init__()
        self.__last_login_ip = &#39;&#39;

    def get_lastip(self):
        return self.__last_login_ip

    def login(self, ip, user):
        print(&#39;[登录成功] 您的登录IP为: &#123;&#125; ,用户名为: &#123;&#125;&#39;.format(ip, user))
        if self.is_lastip(ip):
            self.notifies(self)
        self.__last_login_ip = ip

    def is_lastip(self, ip):
        if self.__last_login_ip != &#39;&#39; and self.__last_login_ip != ip:
            return True


class SMS(Observer):
    def update(self, observable, object):
        print(&#39;[短信通知] 您的账户异地登录，上次登录的IP为： &#123;&#125;&#39;.format(object.get_lastip()))


class Email(Observer):
    def update(self, observable, object):
        print(&#39;[邮件通知] 您的账户异常登录，上次登录的IP为： &#123;&#125;&#39;.format(object.get_lastip()))


if __name__ == &#39;__main__&#39;:
    account = Account()
    account.add_observer(SMS())
    account.add_observer(Email())
    account.login(&#39;1.1.1.1&#39;, &#39;tom&#39;)
    account.login(&#39;2.2.2.2&#39;, &#39;tom&#39;)
    account.login(&#39;2.2.2.2&#39;, &#39;tom&#39;)

    
# output 
[登录成功] 您的登录IP为: 1.1.1.1 ,用户名为: tom
[登录成功] 您的登录IP为: 2.2.2.2 ,用户名为: tom
[短信通知] 您的账户异地登录，上次登录的IP为： 1.1.1.1
[邮件通知] 您的账户异常登录，上次登录的IP为： 1.1.1.1
[登录成功] 您的登录IP为: 2.2.2.2 ,用户名为: tom
</code></pre>
<h2 id="2-状态模式"><a href="#2-状态模式" class="headerlink" title="2. 状态模式"></a>2. 状态模式</h2><ul>
<li><p>状态模式让类可以无缝切换状态，各状态有统一的接口不同的行为。</p>
</li>
<li><p>示例，模仿水在固态、气态、液态切换</p>
<pre><code class="python">from abc import ABCMeta, abstractmethod


class Water:
    def __init__(self):
        self.__temperatrue = 0
        self.__state = None

    def change_state(self, state):
        if self.state is None:
            print(&quot;初始化状态为：&quot;, state.get_name())
        else:
            print(&quot;状态由&quot;, self.__state.get_name(), &quot;变更为：&quot;, state.get_name())

        self.__state = state
    
    # 属性改变时切换状态
    def set_temperature(self, temperature):
        if temperature &lt;= 0:
            self.change_state(SolidState())
        elif temperature &lt;= 100:
            self.change_state(LiquidState())
        else:
            self.change_state(GaseousState())

    def get_temperatrue(self):
        return self.__temperatrue

    def behavior(self):
        self.__state.behavior(self)


class State(metaclass=ABCMeta):
    def __init__(self):
        self.name = &quot;&quot;

    @abstractmethod
    def behavior(self, water):
        pass


class SolidState(State):
    def __init__(self):
        super().__init__()
        self.name = &quot;固态&quot;

    def behavior(self, water):
        print(&quot;我是固态，当前温度为：&quot;, water.get_temperatrue())


class LiquidState(State):
    def __init__(self):
        super().__init__()
        self.name = &quot;液态&quot;

    def behavior(self, water):
        print(&quot;我是液态，当前温度为：&quot;, water.get_temperatrue())


class GaseousState(State):
    def __init__(self):
        super().__init__()
        self.name = &quot;气态&quot;

    def behavior(self, water):
        print(&quot;我是液态，当前温度为：&quot;, water.get_temperatrue())
</code></pre>
</li>
<li><p>主要代码，提供一个状态接口，有统一的行为，当属性更变时即可无缝切换。</p>
<pre><code class="python">class Water:
    def __init__(self):
        self.__temperatrue = 0
        self.__state = None
        
    # 属性改变时切换状态
    def set_temperature(self, temperature):
        if temperature &lt;= 0:
            self.change_state(SolidState())
        elif temperature &lt;= 100:
            self.change_state(LiquidState())
        else:
            self.change_state(GaseousState())

    def behavior(self):
        self.__state.behavior(self)
</code></pre>
</li>
<li><p>基于框架的代码实现。</p>
<pre><code class="python">from abc import ABCMeta, abstractmethod


class Context:
    def __init__(self):
        self.__states = []
        self.__state_info = None
        self.__current_state = None

    def add_state(self, state):
        if state not in self.__states:
            self.__states.append(state)

    def change_state(self, state):
        self.__current_state = state
        self.add_state(state)

    def set_state_info(self):
        for state in self.__states:
            # 降低耦合，把判断条件交给子类区判断
            if state.is_match(self.__state_info):
                self.change_state(state)

    def behavior(self):
        self.__current_state.behavior(self)


class State(metaclass=ABCMeta):
    def __init__(self, name):
        self.name = name

    def get_name(self):
        return self.name

    def is_match(self, state_info):
        return False

    @abstractmethod
    def behavior(self, context):
        pass
</code></pre>
</li>
</ul>
<h2 id="3-中介模式"><a href="#3-中介模式" class="headerlink" title="3. 中介模式"></a>3. 中介模式</h2><ul>
<li><p>中介模式，适用1对多的情况，将中间复杂的关系交给中介处理，个体1只需要处理与中介的逻辑即可。</p>
</li>
<li><p>中介找房案例</p>
<pre><code class="python">class HouseInfo:
    def __init__(self, area, price, has_window, has_bathroom, has_kitchen, address, owner):
        self.__area = area
        self.__price = price
        self.__has_window = has_window
        self.__has_bathroom = has_bathroom
        self.__has_kitchen = has_kitchen
        self.__address = address
        self.__owner = owner

    def get_address(self):
        return self.__address

    def get_onwer_name(self):
        return self.__owner.get_name()

    def show_info(self):
        print(&quot;面积： &quot; + str(self.__area) + &quot;平方米&quot; +
              &quot;价格： &quot; + str(self.__price) + &quot;元&quot; +
              &quot;窗户： &quot; + (&quot;有&quot; if self.__has_window else &quot;没有&quot;) +
              &quot;厨房： &quot; + (&quot;有&quot; if self.__has_kitchen else &quot;没有&quot;) +
              &quot;浴室： &quot; + (&quot;有&quot; if self.__has_bathroom else &quot;没有&quot;))


class HousingAgency:
    def __init__(self, name):
        self.__house_infos = []
        self.__name = name

    def get_name(self):
        return self.__name

    def add_houseinfo(self, houseinfo):
        if houseinfo not in self.__house_infos:
            self.__house_infos.append(houseinfo)

    def remove_houseinfo(self, houseinfo):
        for info in self.__house_infos:
            if info == houseinfo:
                self.__house_infos.remove(info)

    def get_search_condition(self, description):
        return description

    def get_match_infos(self, search_condition):
        print(self.get_name(), &quot;为您找到一下最合适的房源：&quot;)
        for info in self.__house_infos:
            info.show_info()
        return self.__house_infos

    def sign_contract(self, houseinfo, period):
        print(self.get_name(), &quot;与房东&quot;, houseinfo.get_onwer_name(), &quot;签订&quot;, houseinfo.get_address(), &quot;的房子合同，租期为：&quot;, period, &quot;年, 租期内&quot;, self.get_name(), &quot;有权对其进行使用和转租！&quot;)

    def sign_contracts(self, period):
        for info in self.__house_infos:
            self.sign_contract(info, period)


class HouseOwner:
    def __init__(self, name):
        self.__name = name
        self.__houseinfo = None

    def get_name(self):
        return self.__name

    def set_houseinfo(self,  area, price, has_window, has_bathroom, has_kitchen, address, owner):
        self.__houseinfo = HouseInfo(area, price, has_window, has_bathroom, has_kitchen, address, owner)

    def public_houseinfo(self, agency):
        agency.add_houseinfo(self.__houseinfo)
        print(self.get_name(), &quot;在&quot;, agency.get_name(), &quot;发布房源出租信息&quot;)
        self.__houseinfo.show_info()


class Customer:
    def __init__(self, name):
        self.__name = name

    def get_name(self):
        return self.__name

    def find_house(self, description, agency):
        print(&quot;我是&quot; + self.get_name() + &quot;，我想找一个&quot;, description , &quot;的房子&quot;)
        print()
        return agency.get_match_infos(agency.get_search_condition(description))

    def see_house(self, houseinfos):
        size = len(houseinfos)
        return houseinfos[size-1]

    def sign_contract(self, houseinfo, agency, period):
        print(self.get_name(), &quot;与中介&quot;, agency.get_name(), &quot;签订&quot;, houseinfo.get_address(), &quot;的房子的组人合同，租期&quot;, period, &quot;年，合同期内&quot;, self.__name , &quot;有权使用！&quot;)


if __name__ == &#39;__main__&#39;:
    myhome = HousingAgency(&quot;我爱你家&quot;)
    zhangsan = HouseOwner(&quot;张三&quot;)
    zhangsan.set_houseinfo(20, 2600, True, False, False, &quot;上地犀利&quot;, zhangsan)
    zhangsan.public_houseinfo(myhome)

    lisi = HouseOwner(&quot;李四&quot;)
    lisi.set_houseinfo(30, 3800, True, True, True, &quot;西二旗的太阳&quot;, lisi)
    lisi.public_houseinfo(myhome)

    wangwu = HouseOwner(&quot;王五&quot;)
    wangwu.set_houseinfo(40, 5200, True, True, True, &quot;东直门的艾利欧&quot;, wangwu)
    wangwu.public_houseinfo(myhome)
    print()

    myhome.sign_contracts(3)
    print()

    tony = Customer(&quot;Tony&quot;)
    houseinfos = tony.find_house(&quot;18平方米，要有独立卫生间，要有窗户，最好朝南，有厨房更好！价位200左右&quot;, myhome)
    print()

    print(&quot;正在看房，寻找最合适的房子&quot;)
    print()

    appropriate_house = tony.see_house(houseinfos)
    print()
    tony.sign_contract(appropriate_house, myhome, 1)

</code></pre>
</li>
<li><p>主要代码，没有主要代码，上述案例只是一种体现中介模式的方式，中介将个人与房东联合的操作聚合在一个类中，方便了个人与房东，但是复杂了中介类。</p>
</li>
<li><p>设备驱动案例</p>
<pre><code class="python">from abc import ABCMeta, abstractmethod
from enum import Enum


class DeviceType(Enum):
    TypeSpeaker = 1
    TypeMicrophone = 2
    TypeCamera = 3


class DeviceItem:
    def __init__(self, id, name, type, isDefault=False):
        self.__id = id
        self.__name = name
        self.__type = type
        self.__isDefault = isDefault

    def __str__(self):
        return &quot;type: &quot; + str(self.__type) + &quot;id: &quot; + str(self.__id) + &quot;name: &quot; + str(
            self.__name) + &quot;isDefault: &quot; + str(self.__isDefault)

    def getId(self):
        return self.__id

    def getNmae(self):
        return self.__name

    def getType(self):
        return self.__type

    def isDefault(self):
        return self.__isDefault


class DeviceList:
    def __init__(self):
        self.__devices = []

    def add(self, deviceItem):
        self.__devices.append(deviceItem)

    def getCount(self):
        return len(self.__devices)

    def getByIdx(self, idx):
        if idx &lt; 0 or idx &gt;= self.getCount():
            return None
        return self.__devices[idx]

    def getById(self, id):
        for item in self.__devices:
            if item.getId() == id:
                return item
        return None


class DeviceMgr(metaclass=ABCMeta):
    @abstractmethod
    def enumerate(self):
        pass

    @abstractmethod
    def active(self, deviceId):
        pass

    @abstractmethod
    def getCurDeviceId(self):
        pass


class SpeakerMgr(DeviceMgr):
    def __init__(self):
        self.__curDeviceId = None

    def enumerate(self):
        devices = DeviceList()
        devices.add(
            DeviceItem(&quot;37dd1024-843b-83a1-934c-81ac9230111&quot;, &quot;Realtek HighDefinition Audio&quot;, DeviceType.TypeSpeaker,
                       True))
        devices.add(
            DeviceItem(&quot;215a41c60-1313-24aa-1241-324ac3f445&quot;, &quot;NVIDIA HighDefinition Audio&quot;, DeviceType.TypeSpeaker,
                       True))
        return devices

    def active(self, deviceId):
        self.__curDeviceId = deviceId

    def getCurDeviceId(self):
        return self.__curDeviceId


class DeviceUtil:
    def __init__(self):
        self.__mgrs = &#123;DeviceType.TypeSpeaker: SpeakerMgr()&#125;
        # self.__microphoneMgr =

    def __getDeviceMgr(self, type):
        return self.__mgrs[type]

    def getDeviceList(self, type):
        return self.__getDeviceMgr(type).enumerate()

    def active(self, type, deviceId):
        self.__getDeviceMgr(type).active(deviceId)

    def getCurDeviceId(self, type):
        return self.__getDeviceMgr(type).getCurDeviceId()


if __name__ == &#39;__main__&#39;:
    deviceUtil = DeviceUtil()
    deviceList = deviceUtil.getDeviceList(DeviceType.TypeSpeaker)
    print(&quot;麦克风设备列表：&quot;)
    if devDeviceItemiceList.getCount() &gt; 0:
        deviceUtil.active(DeviceType.TypeSpeaker, deviceList.getByIdx(0).getId())

    for idx in range(0, deviceList.getCount()):
        device = deviceList.getByIdx(idx)
        print(device)
        print(&quot;当前使用的设备：&quot; + deviceList.getById(deviceUtil.getCurDeviceId(DeviceType.TypeSpeaker)).getNmae())
</code></pre>
</li>
<li><p>分析，上述代码是将DeviceMgr作为中介，在一对多的关系中，DeviceItem是多，DeviceUtil是1，DeviceMgr将一个类型的驱动聚合，提供给DeviceUtil用。</p>
<pre><code class="python">DeviceItem
DeviceMgr
SpeakerMgr
DeviceUtil
</code></pre>
</li>
</ul>
<h2 id="4-装饰模式"><a href="#4-装饰模式" class="headerlink" title="4. 装饰模式"></a>4. 装饰模式</h2><ul>
<li><p>装饰模式，可以让类在不改变自身的前提下添加更多功能</p>
</li>
<li><p>装饰模式实现的主要地方在于装饰类继承被装饰类、去嵌套执行被装饰者的方法并且额外扩充功能</p>
<pre><code class="python">class Person(metaclass=ABCMeta):
    def __init__(self, name):
        self._name = name

    @abstractmethod
    def wear(self):
        print(&quot;着装：&quot;)

class ClothingDecorator(Person):
    def __init__(self, person):
        self._decorated = person

    def wear(self):
        self._decorated.wear()
        self.decorate()

    @abstractmethod
    def decorate(self):
        pass

class CasulPantDecorator(ClothingDecorator):
    def __init__(self, person):
        super().__init__(person)

    def decorate(self):
        print(&quot;一条卡其色休闲裤&quot;)

if __name__ == &#39;__main__&#39;:
    tony = Engineer(&quot;Tony&quot;, &quot;客户端开发&quot;)
    pant = CasulPantDecorator(tony)
    belt = BeltDecorator(pant)
    shoes = LeatherShoesDecorator(belt)
    sweater = KnittedSweaterDecorator(shoes)
    glasses = GlassedDecorator(sweater)
    glasses.wear()
</code></pre>
</li>
<li><p>主要代码，主要在这个ClothingDecorator类上，可以递归继承，调用</p>
<pre><code class="python">class ClothingDecorator(Person):
    def __init__(self, person):
        self._decorated = person
    def wear(self):
        self._decorated.wear()
        self.decorate()


        
</code></pre>
</li>
<li><p>装饰器，单例模式装饰器</p>
<pre><code class="python">def singletonDecorator(cls, *args, **kwargs):
    instance = &#123;&#125;
    # 创建一个字典，以类名作为键 实例作为值，当装饰器运行时先判断是否存在，如果存在则返回实例
    def wrapperSingleton(*args, **kwargs):
        if cls not in instance:
            instance[cls] = cls(*args, **kwargs)
        return instance[cls]
       
    return wrapperSingleton
</code></pre>
</li>
</ul>
<h2 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5. 单例模式"></a>5. 单例模式</h2><ul>
<li><p>单例模式，全局唯一实例</p>
<pre><code class="python">class MyBeaultifulGril(object):
    __instance = None
    __isFirstInit = False
    
    # 魔术方法，调用前先判断是否已有实例
    def __new__(cls, name):
        if not cls.__instance:
            MyBeaultifulGril.__instance = super().__new__(cls)
        return cls.__instance

    def __init__(self, name):
        if not self.__isFirstInit:
            self.__name = name
            print(&quot;遇见&quot; + name + &quot;, 我一见钟情&quot;)
            self.__isFirstInit = True
        else:
            print(&quot;遇见&quot; + name + &quot;, 我置若罔闻！&quot;)

    def showMyHeart(self):
        print(self.__name + &quot;就是我心中的唯一！&quot;)


if __name__ == &#39;__main__&#39;:
    jenny = MyBeaultifulGril(&quot;Jenney&quot;)
    jenny.showMyHeart()
    print()
    kimi = MyBeaultifulGril(&quot;kimi&quot;)
    kimi.showMyHeart()
    print(&quot;id(jenny):&quot;, id(jenny), &quot;id(kimi)&quot;, id(kimi))
</code></pre>
</li>
<li><p>主要代码，使用python内置的模式方法实现单例</p>
<pre><code class="python">    # 魔术方法，调用前先判断是否已有实例
    def __new__(cls, name):
        if not cls.__instance:
            MyBeaultifulGril.__instance = super().__new__(cls)
        return cls.__instance
</code></pre>
</li>
</ul>
<h2 id="6-克隆模式"><a href="#6-克隆模式" class="headerlink" title="6.克隆模式"></a>6.克隆模式</h2><ul>
<li><p>克隆模式（也叫原型模式），主要用于克隆属性 ，python的克隆可以用类库来实现</p>
<pre><code class="python">from copy import  copy, deepcopy


class Person:
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def showMySelf(self):
        print(&quot;我是&quot; + self.__name + &quot;,年龄&quot; + str(self.__age) + &quot;,&quot;)

    def coding(self):
        print(&quot;我是码农，我用程序改变世界，Coding...&quot;)

    def reading(self):
        print(&quot;阅读是我快乐！知识是我成长！如饥似渴地阅读是生活的一部分....&quot;)

    def fallInLove(self):
        print(&quot;春风吹，月亮明，花前月下好相约....&quot;)

    def clone(self):
        return copy(self)


if __name__ == &#39;__main__&#39;:
    tony = Person(&quot;Tony&quot;, 27)
    tony.showMySelf()
    tony.coding()

    print()

    tony1 = tony.clone()
    tony1.showMySelf()
    tony1.reading()

    print()

    tony2 = tony.clone()
    tony2.showMySelf()
    tony2.fallInLove()
</code></pre>
<ul>
<li>浅拷贝只拷贝应用类型对象的指针（指向），不开被引用类型对象指向的值；深拷贝则同事拷贝引用类型对象及其指向的值。</li>
</ul>
</li>
</ul>
<h2 id="7-职责模式"><a href="#7-职责模式" class="headerlink" title="7. 职责模式"></a>7. 职责模式</h2><ul>
<li><p>职责模式 ，解耦请求和处理端，请求端只需要知道下一级是谁即可，处理端只需要处理在自己范围内的事即可。</p>
</li>
<li><p>注意点：设计好下级处理对象，下级对象根据条件匹配，如果相符则执行</p>
<pre><code class="python">from abc import ABCMeta, abstractmethod


class Person:
    def __init__(self, name, dayoff, reason):
        self.__name = name
        self.__dayoff = dayoff
        self.__reason = reason
        self.__leader = None

    def getName(self):
        return self.__name

    def getDayoff(self):
        return self.__dayoff

    def getReason(self):
        return self.__reason

    def setLeader(self, leader):
        self.__leader = leader

    def request(self):
        print(&quot;%s 申请请假 %d 天,请假事由： %s&quot; % (self.__name, self.__dayoff, self.__reason))
        if self.__leader is not None:
            self.__leader.handleRequest(self)


class Manager(metaclass=ABCMeta):
    def __init__(self, name, title):
        self.__name = name
        self.__title = title
        self._nextHandler = None

    def getName(self):
        return self.__name

    def getTitle(self):
        return self.__title

    def setNextHandle(self, nextHandler):
        self._nextHandler = nextHandler

    @abstractmethod
    def handleRequest(self, person):
        pass


class Supervisor(Manager):
    def __init__(self, name, title):
        super().__init__(name, title)

    def handleRequest(self, person):
        if person.getDayoff() &lt;= 2:
            print(&quot;同意 %s 请假，签字人：%s (%s)&quot; % (person.getName(), self.getName(), self.getTitle()))

        if self._nextHandler is not None:
            self._nextHandler.handleRequest(person)

class DepartmentManager(Manager):
    def __init__(self, name, title):
        super().__init__(name, title)

    def handleRequest(self, person):
        if person.getDayoff() &gt; 2 and person.getDayoff() &lt;= 5:
            print(&quot;同意 %s 请假，签字人：%s (%s)&quot; % (person.getName(), self.getName(), self.getTitle()))

        if self._nextHandler is not None:
            self._nextHandler.handleRequest(person)


class CEO(Manager):
    def __init__(self, name, title):
        super().__init__(name, title)

    def handleRequest(self, person):
        if person.getDayoff() &gt; 5 and person.getDayoff() &lt;= 22:
            print(&quot;同意 %s 请假，签字人：%s (%s)&quot; % (person.getName(), self.getName(), self.getTitle()))

        if self._nextHandler is not None:
            self._nextHandler.handleRequest(person)


class Administrator(Manager):
    def __init__(self, name, title):
        super().__init    # 魔术方法，调用前先判断是否已有实例
    def __new__(cls, name):
        if not cls.__instance:
            MyBeaultifulGril.__instance = super().__new__(cls)
        return cls.__instance__(name, title)

    def handleRequest(self, person):
        print(&quot;%s 的请假申请已审核，情况属实！已备案处理，处理人：%s(%s)\n&quot; % (person.getName(), self.getName(), self.getTitle()))


if __name__ == &#39;__main__&#39;:
    directLeader = Supervisor(&quot;Eren&quot;, &quot;客户端研发部经理&quot;)
    departmentLeader = DepartmentManager(&quot;Eric&quot;, &quot;技术研发中心总监&quot;)
    ceo = CEO(&quot;Helen&quot;, &quot;创新文化公司CEO&quot;)
    administrator = Administrator(&quot;Nina&quot;, &quot;行政中心总监&quot;)
    directLeader.setNextHandle(departmentLeader)
    departmentLeader.setNextHandle(ceo)
    ceo.setNextHandle(administrator)

    sunny = Person(&quot;sunny&quot;, 1, &quot;参加MDCC大会&quot;)
    sunny.setLeader(directLeader)
    sunny.request()

    tony = Person(&quot;tony&quot;, 5, &quot;家里有紧急事情！&quot;)
    tony.setLeader(directLeader)
    tony.request()

    pony = Person(&quot;Pony&quot;, 15, &quot;出国深造。&quot;)
    pony.setLeader(directLeader)
    pony.request()
</code></pre>
</li>
<li><p>主要代码，链上的各个节点都设置好下一级的处理对象，各节点上的对象只有处理的条件符合时才处理。</p>
<pre><code class="python">class Manager(metaclass=ABCMeta):
    def __init__(self, name, title):
        self._nextHandler = None
        
    def setNextHandle(self, nextHandler):
        self._nextHandler = nextHandler

    @abstractmethod
    def handleRequest(self, person):
        pass
        
        if self._nextHandler is not None:
            self._nextHandler.handleRequest(person)
</code></pre>
</li>
</ul>
<h2 id="8-代理模式"><a href="#8-代理模式" class="headerlink" title="8. 代理模式"></a>8. 代理模式</h2><ul>
<li><p>代理模式，间接执行真正的主体，协调双方也方便控制</p>
<pre><code class="python">from abc import ABCMeta, abstractmethod


class ReceiveParcel(metaclass=ABCMeta):

    def __init__(self, name):
        self.__name = name

    def getName(self):
        return self.__name

    @abstractmethod
    def receive(self, parcelContent):
        pass


class TonyReception(ReceiveParcel):

    def __init__(self, name, phoneNum):
        super().__init__(name)
        self.__phoneNum = phoneNum

    def getPhoneNum(self):
        return self.__phoneNum

    def receive(self, parcelContent):
        print(&quot;货物主人： %s ,手机号： %s &quot; % (self.getName(), self.getPhoneNum()))
        print(&quot;接收到一个包裹，包裹内容： %s &quot; % parcelContent)


class WendyReception(ReceiveParcel):

    def __init__(self, name, receiver):
        super().__init__(name)
        self.__receiver = receiver

    def receive(self, parcelContent):
        print(&quot;我是%s的朋友，我来帮他收快递！&quot; %(self.__receiver.getName() + &quot; &quot; ))
        if self.__receiver is not None:
            self.__receiver.receive(parcelContent)

if __name__ == &#39;__main__&#39;:
    tony = TonyReception(&quot;Tony&quot;, &quot;18888888888&quot;)
    print(&quot;Tony接受：&quot;)
    tony.receive(&quot;雪地靴&quot;)
    print()

    print(&quot;Wendy代收：&quot;)
    wendy = WendyReception(&quot;Wendy&quot;, tony)
    wendy.receive(&quot;雪地靴&quot;)
</code></pre>
</li>
<li><p>主要代码，代理类传入需要代理的对象，在执行代理对象的方法之前可以进行控制处理。</p>
<pre><code class="python">class WendyReception(ReceiveParcel):

    def __init__(self, name, receiver):
        super().__init__(name)
        self.__receiver = receiver

    def receive(self, parcelContent):
        print(&quot;我是%s的朋友，我来帮他收快递！&quot; %(self.__receiver.getName() + &quot; &quot; ))
        if self.__receiver is not None:
            self.__receiver.receive(parcelContent)
</code></pre>
</li>
</ul>
<h2 id="9-外观模式"><a href="#9-外观模式" class="headerlink" title="9. 外观模式"></a>9. 外观模式</h2><ul>
<li><p>外观模式，也叫门户模式，将多个复杂的接口封装成一个，以供用户使用。</p>
<pre><code class="python">class Register:
    def register(self, name):
        print(&quot;活动中心： %s 同学报道成功！&quot; % name)


class Payment:
    def pay(self, name, money):
        print(&quot;缴费中心：收到%s同学%s元付款，缴费成功！&quot; % (name, money))


class DormitoryManagementCenter:
    def provideLivingGoods(self, name):
        print(&quot;生活中心：%s 同学的生活用品已发放。&quot; % name)


class Dormitory:
    def meetRoommate(self, name):
        print(&quot;宿舍： 大家好！这是刚来的 %s同学，是你们未来需要共读四年的室友！相互认识一下....&quot; % name)


class Volunteer:
    def __init__(self, name):
        self.__name = name
        self.__register = Register()
        self.__payment = Payment()
        self.__lifeCenter = DormitoryManagementCenter()
        self.__dormintory = Dormitory()

    def welcomeFreshmen(self, name):
        print(&quot;您好，%s同学！ 我是新生报到的志愿者%s,我将带你完成整个报道流程。&quot; % (name, self.__name))
        self.__register.register(name)
        self.__payment.pay(name, 10000)
        self.__lifeCenter.provideLivingGoods(name)
        self.__dormintory.meetRoommate(name)

if __name__ == &#39;__main__&#39;:
    volunteer = Volunteer(&quot;Frank&quot;)
    volunteer.welcomeFreshmen(&quot;tony&quot;)
</code></pre>
</li>
<li><p>主要代码，外观模式很像中介模式，将本来一对多的关系转换为一对一，由外观类去处理多，区别在于外观模式注重提供统一的对外接口，中介模式注重于双方的交互。</p>
<pre><code class="python">class Volunteer:
    def __init__(self, name):
        self.__name = name
        self.__register = Register()
        self.__payment = Payment()
        self.__lifeCenter = DormitoryManagementCenter()
        self.__dormintory = Dormitory()
</code></pre>
</li>
</ul>
<h2 id="10-迭代模式"><a href="#10-迭代模式" class="headerlink" title="10 迭代模式"></a>10 迭代模式</h2><ul>
<li><p>迭代模式，提供一种对象的顺序访问方式，Python对迭代支持的非常好（for …. in）</p>
<pre><code class="python">class Customer:
    def __init__(self, name):
        self.__name = name
        self.__num = 0
        self.__clinics = None

    def getName(self):
        return self.__name

    def register(self, system):
        system.pushCustomer(self)

    def setNum(self, num):
        self.__num = num

    def getNum(self):
        return self.__num

    def setClinic(self, clinic):
        self.__clinics = clinic

    def getClinic(self):
        return self.__clinics


class NumeralIterator:
    def __init__(self, data):
        self.__data = data
        self.__curIdx = -1

    def next(self):
        if self.__curIdx &lt; len(self.__data) -1:
            self.__curIdx += 1
            return True
        else:
            return False

    def current(self):
        return self.__data[self.__curIdx] if self.__curIdx &lt; len(self.__data) and self.__curIdx &gt;= 0 else None


class NumberalSystem:
    __clinics = (&quot;1号诊室&quot;, &quot;2号正式诊室&quot;, &quot;3号正式诊室&quot;)

    def __init__(self, name):
        self.__customers = []
        self.__curNum = 0
        self.__name = name

    def pushCustomer(self, customer):
        customer.setNum(self.__curNum + 1)
        click = NumberalSystem.__clinics[self.__curNum % len(NumberalSystem.__clinics)]
        customer.setClinic(click)
        self.__curNum += 1
        self.__customers.append(customer)
        print(&quot;%s 您好！ 您已在 %s 成功挂号，序号：%04d，请耐心等待！&quot; % (customer.getName(), self.__name, customer.getNum()))

    def getIterator(self):
        return NumeralIterator(self.__customers)


if __name__ == &#39;__main__&#39;:
    numeralSystem = Nclass Volunteer:
    def __init__(self, name):
        self.__name = name
        self.__register = Register()
        self.__payment = Payment()
        self.__lifeCenter = DormitoryManagementCenter()
        self.__dormintory = Dormitory()umberalSystem(&quot;挂号台&quot;)
    lily = Customer(&quot;Lily&quot;)
    lily.register(numeralSystem)
    pony = Customer(&quot;Pony&quot;)
    pony.register(numeralSystem)
    nick = Customer(&quot;Nick&quot;)
    nick.register(numeralSystem)
    tony = Customer(&quot;Tony&quot;)
    tony.register(numeralSystem)class WendyReception(ReceiveParcel):

    def __init__(self, name, receiver):
        super().__init__(name)
        self.__receiver = receiver

    def receive(self, parcelContent):
        print(&quot;我是%s的朋友，我来帮他收快递！&quot; %(self.__receiver.getName() + &quot; &quot; ))
        if self.__receiver is not None:
            self.__receiver.receive(parcelContent)
    print()

    iterator = numeralSystem.getIterator()
    while(iterator.next()):
        customer = iterator.current()
        print(&quot;下一位病人 %04d(%s) 请到 %s 就诊。&quot; % (customer.getNum(), customer.getName(), customer.getClinic()))
</code></pre>
</li>
<li><p>主要代码，没什么好说的，在其他语言里面这是一种数据、对象的遍历方式，在python里面也是，只不过python内置很多迭代器。</p>
<pre><code class="python">class NumeralIterator:
    def __init__(self, data):
        self.__data = data
        self.__curIdx = -1

    def next(self):
        if self.__curIdx &lt; len(self.__data) -1:
            self.__curIdx += 1
            return True
        else:
            return False

    def current(self):
        return self.__data[self.__curIdx] if self.__curIdx &lt; len(self.__data) and self.__curIdx &gt;= 0 else None
</code></pre>
</li>
</ul>
<h2 id="11-组合模式"><a href="#11-组合模式" class="headerlink" title="11 组合模式"></a>11 组合模式</h2><ul>
<li><p>组合模式，复杂的功能可以分解成多个组件，组件之间相互组合构成更多功能。</p>
<pre><code class="python">from abc import ABCMeta, abstractmethod


class ComputerComponent(metaclass=ABCMeta):
    def __init__(self, name):
        self._name = name

    @abstractmethod
    def showInfo(self, indent=&quot; &quot;):
        pass

    def isComposite(self):
        return False

    def startup(self, indent=&quot; &quot;):
        print(&quot;%s%s 准备开始工作...&quot; % (indent, self._name))

    def shutdown(self, indent=&quot; &quot;):
        print(&quot;%s%s 即将结束工作...&quot; % (indent, self._name))


class CPU(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):
        print(&quot;%sCPU:%s,可以进行告诉运算。 &quot; % (indent, self._name))


class MemoryCard(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):
        print(&quot;%s内存:%s,可以缓存数据，读写更快。 &quot; % (indent, self._name))


class HardDisk(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):
        print(&quot;%s硬盘:%s,可以永久存储数据，容量大。 &quot; % (indent, self._name))


class GraphicsCard(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):
        print(&quot;%s显卡:%s,可以高速计算和处理图形图像。 &quot; % (indent, self._name))


class Battery(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):
        print(&quot;%s电源:%s,可以持续给主板和外界配件供电。 &quot; % (indent, self._name))


class Fan(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):
        print(&quot;%s风扇:%s,可以持续给主板和外界配件供电。 &quot; % (indent, self._name))


class Displayer(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):
        print(&quot;%s显示器:%s,可以显示界面和打游戏。 &quot; % (indent, self._name))

class ComputerComposite(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)
        self._components = []

    def showInfo(self, indent):
        print(&quot;%s,由一下部件组成：&quot; % self._name)
        indent += &#39;\t&#39;
        for element in self._components:
            element.showInfo(indent)

    def isComposite(self):
        return True

    def addComposite(self, component):
        self._components.append(component)

    def removeComponent(self, component):
        self._components.remove(component)

    def startup(self, indent):
        super().startup(indent)
        indent += &#39;\t&#39;
        for element in self._components:
            element.startup(indent)

    def shutdown(self, indent):
        super().shutdown(indent)
        indent += &#39;\t&#39;
        for element in self._components:
            element.shutdown(indent)


class MainBoard(ComputerComposite):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):组合模式
        print(indent + &quot;主板：&quot;, end=&quot;&quot;)
        super().showInfo(indent)


class ComputerCase(ComputerComposite):
    def __init__(self, name):
        super().__init__(name)

    def showInfo(self, indent):
        print(indent + &quot;机箱:&quot;, end=&quot;&quot;)
        super().showInfo(indent)


class Computer(ComputerComposite):
    def __init__(self, name):
        super().__init__(name)组合模式

    def showInfo(self, indent):
        print(indent, &quot;电脑：&quot;, end=&quot;&quot;)
        super().showInfo(indent)


if __name__ == &#39;__main__&#39;:
    mainBoard = MainBoard(&quot;GIGABYTE Z179M M-ATX&quot;)
    mainBoard.addComposite(CPU(&quot;Intel Core I5-5500k&quot;))
    mainBoard.addComposite(MemoryCard(&quot;Kingston Fury DDR4&quot;))
    mainBoard.addComposite(HardDisk(&quot;Kingston V300&quot;))
    mainBoard.addComposite(GraphicsCard(&quot;Colorful iGame750&quot;))

    computerCase = ComputerCase(&quot;SAMA MATX&quot;)
    computerCase.addComposite(mainBoard)
    computerCase.addComposite(Battery(&quot;Anter VP 450P&quot;))
    computerCase.addComposite(Fan(&quot;DEEPCOOL 120T&quot;))

    computer = Computer(&quot;Tony DIV 电脑&quot;)
    computer.addComposite(computerCase)
    computer.addComposite(Displayer(&quot;AOC Lv24XIP&quot;))

    computer.showInfo(&quot;&quot;)
    print(&quot;\n 开机过程&quot;)
    computer.startup(&quot;&quot;)
    print(&quot;\n 关机过程&quot;)
    computer.shutdown(&quot;&quot;)
</code></pre>
</li>
<li><p>主要代码 ，组合模式注重于将多个零件相互组合成一个复杂的系统。</p>
<pre><code class="python">class ComputerComposite(ComputerComponent):
    def __init__(self, name):
        super().__init__(name)
        self._components = []

    def showInfo(self, indent):

    def addComposite(self, component):
        self._components.append(component)

    def removeComponent(self, component):
        self._components.remove(component)

    def startup(self, indent):

    def shutdown(self, indent):
</code></pre>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2022/01/09/%E6%B2%99%E7%AE%B1%E7%8E%AF%E5%A2%83%E6%A3%80%E6%B5%8B%E5%92%8C%E7%BB%95%E8%BF%87/">prev</a><a class="next" href="/2022/01/09/%E9%80%9A%E8%BF%87%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8Cshellcode/">next</a></div><div class="copyright"><p>&copy; 2023 <a href="http://example.com">Hurn</a>.<br>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/Dreyer/hexo-theme-artemis" target="_blank">Artemis</a>.</p></div></footer></div></body></html>